category: Forensics & Malware Analysis
commonfields:
  id: vmray
  version: -1
configuration:
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: C - Fairly reliable
  display: Source Reliability
  name: integrationReliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: false
  type: 15
- defaultvalue: https://cloud.vmray.com
  display: Server URL (e.g., https://cloud.vmray.com)
  name: server
  required: true
  type: 0
- display: ""
  displaypassword: API Key (Recommended)
  hiddenusername: true
  name: credentials
  required: false
  type: 9
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- additionalinfo: Use the "API Key (Recommended)" parameter instead.
  display: API Key (Deprecated)
  name: api_key
  required: false
  type: 4
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.1.6
    packID: VMRay
    packName: VMRay Analyzer
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Malware analysis sandboxing.
detaileddescription: "### Partner Contributed Integration\n#### Integration Author:
  VMRay\nSupport and maintenance for this integration are provided by the author.
  Please use the following contact details:\n- **Email**: [support@vmray.com](mailto:support@vmray.com)\n-
  **URL**: [https://www.vmray.com/](https://www.vmray.com/)\n***\n# How To get your
  VMRay API Key\n1. Access your VMRay environment.\n2. Navigate to **VMRay -> Profile
  -> API KEYS**. \n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/vmray)"
display: VMRay (Partner Contribution)
image: data:image/png;base64,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
name: vmray
script:
  commands:
  - arguments:
    - description: Entry ID of the file to submit.
      name: entry_id
      required: true
    - description: Password of the document.
      name: document_password
    - description: Password of an archive.
      name: archive_password
    - description: Force type of the file.
      name: sample_type
    - auto: PREDEFINED
      description: Whether the file is shareable.
      name: shareable
      predefined:
      - "true"
      - "false"
    - default: true
      defaultValue: "1"
      description: Maximum number of jobs to create (number).
      name: max_jobs
    - description: A CSV list of tags to add to the sample.
      name: tags
    - auto: PREDEFINED
      description: Deprecated. Analyze even if analyses already exist. To control
        analysis caching, use the API Key settings instead, which are available via
        the Analysis Settings page, in the VMRay Web Interface.
      name: reanalyze
      predefined:
      - "true"
      - "false"
    description: Submits a sample to VMRay for analysis.
    name: vmray-upload-sample
    outputs:
    - contextPath: VMRay.Job.JobID
      description: ID of a new job
      type: Number
    - contextPath: VMRay.Job.Created
      description: Timestamp of job creation.
      type: Date
    - contextPath: VMRay.Job.SampleID
      description: ID of the sample.
      type: Number
    - contextPath: VMRay.Job.VMName
      description: Name of the virtual machine.
      type: String
    - contextPath: VMRay.Job.VMID
      description: ID of the virtual machine.
      type: Number
    - contextPath: VMRay.Sample.SampleID
      description: ID of the sample.
      type: Number
    - contextPath: VMRay.Sample.SampleURL
      description: URL to sample page.
      type: String
    - contextPath: VMRay.Sample.Created
      description: Timestamp of sample creation.
      type: Date
    - contextPath: VMRay.Submission.SubmissionID
      description: Submission ID.
      type: Number
    - contextPath: VMRay.Submission.SubmissionURL
      description: URL to submission page.
      type: String
  - arguments:
    - description: ' The URL to analyze. For example: https://demisto.com. '
      name: url
      required: true
    - auto: PREDEFINED
      description: Whether the analysis is shareable.
      name: shareable
      predefined:
      - "true"
      - "false"
    - default: true
      defaultValue: "1"
      description: Maximum number of jobs to create (number).
      name: max_jobs
    - description: A CSV list of tags to add to the sample.
      name: tags
    description: Submits a URL for analysis.
    name: vmray-upload-url
    outputs:
    - contextPath: VMRay.Job.JobID
      description: ID of a new job
      type: Number
    - contextPath: VMRay.Job.Created
      description: Timestamp of job creation.
      type: Date
    - contextPath: VMRay.Job.SampleID
      description: ID of the sample.
      type: Number
    - contextPath: VMRay.Job.VMName
      description: Name of the virtual machine.
      type: String
    - contextPath: VMRay.Job.VMID
      description: ID of the virtual machine.
      type: Number
    - contextPath: VMRay.Sample.SampleID
      description: ID of the sample.
      type: Number
    - contextPath: VMRay.Sample.SampleURL
      description: URL to sample page.
      type: String
    - contextPath: VMRay.Sample.Created
      description: Timestamp of sample creation.
      type: Date
    - contextPath: VMRay.Submission.SubmissionID
      description: Submission ID.
      type: Number
    - contextPath: VMRay.Submission.SubmissionURL
      description: URL to submission page.
      type: String
  - arguments:
    - description: Sample ID.
      name: sample_id
      required: true
    - description: Maximum number of results to return (number).
      name: limit
    description: Retrieves all analysis details for a specified sample.
    name: vmray-get-analysis-by-sample
    outputs:
    - contextPath: VMRay.Analysis.AnalysisID
      description: Analysis ID.
      type: Number
    - contextPath: VMRay.Analysis.AnalysisURL
      description: URL to analysis page.
      type: String
    - contextPath: VMRay.Analysis.SampleID
      description: Sample ID in the analysis.
      type: Number
    - contextPath: VMRay.Analysis.Verdict
      description: Verdict for the sample (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Analysis.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Analysis.Severity
      description: Severity of the sample in the submission (Malicious, Suspicious,
        Good, Blacklisted, Whitelisted, Unknown). Deprecated.
      type: String
    - contextPath: VMRay.Analysis.JobCreated
      description: Date when the analysis job started.
      type: Date
    - contextPath: VMRay.Analysis.MD5
      description: MD5 hash of the sample.
      type: String
    - contextPath: VMRay.Analysis.SHA1
      description: SHA1 hash of the sample.
      type: String
    - contextPath: VMRay.Analysis.SHA256
      description: SHA256 hash of the sample.
      type: String
    - contextPath: VMRay.Analysis.SSDeep
      description: ssdeep hash of the sample.
      type: String
  - arguments:
    - description: Sample ID.
      name: sample_id
      required: true
    description: Retrieves details for all jobs  for a specified sample.
    name: vmray-get-job-by-sample
    outputs:
    - contextPath: VMRay.Job.JobID
      description: ID of the job.
      type: Number
    - contextPath: VMRay.Job.SampleID
      description: Sample ID of the job.
      type: Number
    - contextPath: VMRay.Job.SubmissionID
      description: ID of the submission.
      type: Number
    - contextPath: VMRay.Job.MD5
      description: MD5 hash of the sample in the job.
      type: String
    - contextPath: VMRay.Job.SHA1
      description: SHA1 hash of the sample in the job.
      type: String
    - contextPath: VMRay.Job.SHA256
      description: SHA256 hash of the sample in the job.
      type: String
    - contextPath: VMRay.Job.SSDeep
      description: ssdeep hash of the sample in the job.
      type: String
    - contextPath: VMRay.Job.VMName
      description: Name of the virtual machine.
      type: String
    - contextPath: VMRay.Job.VMID
      description: ID of the virtual machine.
      type: Number
    - contextPath: VMRay.Job.Status
      description: 'Status of the job. '
      type: String
  - arguments:
    - description: ID of the submission. Can be obtained by running the 'vmray-upload-sample'
        or 'vmray-upload-url' command.
      name: submission_id
      required: true
    description: Retrieves the results of a submission.
    name: vmray-get-submission
    outputs:
    - contextPath: VMRay.Submission.IsFinished
      description: Whether the submission is finished (true or false).
      type: Boolean
    - contextPath: VMRay.Submission.HasErrors
      description: Whether there are any errors in the submission (true or false).
      type: Boolean
    - contextPath: VMRay.Submission.SubmissionID
      description: ID of the sample in the submission.
      type: Number
    - contextPath: VMRay.Submission.SubmissionURL
      description: URL of submission page.
      type: String
    - contextPath: VMRay.Submission.MD5
      description: MD5 hash of the sample in the submission.
      type: String
    - contextPath: VMRay.Submission.SHA1
      description: SHA1 hash of the sample in the submission.
      type: String
    - contextPath: VMRay.Submission.SHA256
      description: SHA256 hash of the sample in the submission.
      type: String
    - contextPath: VMRay.Submission.SSDeep
      description: ssdeep hash of the sample in the submission.
      type: String
    - contextPath: VMRay.Submission.Verdict
      description: Verdict for the sample (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Submission.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Submission.Severity
      description: Severity of the sample in the submission (Malicious, Suspicious,
        Good, Blacklisted, Whitelisted, Unknown). Deprecated.
      type: String
    - contextPath: VMRay.Submission.SampleID
      description: ID of the sample in the submission.
      type: Number
  - arguments:
    - description: ID of the sample.
      name: sample_id
      required: true
    description: Retrieves a sample using the sample ID.
    name: vmray-get-sample
    outputs:
    - contextPath: VMRay.Sample.SampleID
      description: ID of the sample.
      type: Number
    - contextPath: VMRay.Sample.SampleURL
      description: URL to sample page.
      type: String
    - contextPath: VMRay.Sample.FileName
      description: File name of the sample.
      type: String
    - contextPath: VMRay.Sample.MD5
      description: MD5 hash of the sample.
      type: String
    - contextPath: VMRay.Sample.SHA1
      description: SHA1 hash of the sample.
      type: String
    - contextPath: VMRay.Sample.SHA256
      description: SHA256 hash of the sample.
      type: String
    - contextPath: VMRay.Sample.SSDeep
      description: ssdeep hash of the sample.
      type: String
    - contextPath: VMRay.Sample.Verdict
      description: Verdict for the sample (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.Severity
      description: Severity of the sample in the submission (Malicious, Suspicious,
        Good, Blacklisted, Whitelisted, Unknown). Deprecated.
      type: String
    - contextPath: VMRay.Sample.Type
      description: File type.
      type: String
    - contextPath: VMRay.Sample.Created
      description: Timestamp of sample creation.
      type: Date
    - contextPath: VMRay.Sample.Classifications
      description: Classifications of the sample.
      type: String
    - contextPath: VMRay.Sample.ChildSampleIDs
      description: List of child sample IDs.
      type: Number
    - contextPath: VMRay.Sample.ParentSampleIDs
      description: List of parent sample IDs.
      type: Number
  - arguments:
    - description: MD5, SHA1 or SHA256 hash of the sample.
      name: hash
      required: true
    description: Retrieves sample information by hash.
    name: vmray-get-sample-by-hash
    outputs:
    - contextPath: File.Name
      description: The full file name (including file extension).
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SSDeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: VMRay.Sample.SampleID
      description: ID of the sample.
      type: Number
    - contextPath: VMRay.Sample.SampleURL
      description: URL to sample page.
      type: String
    - contextPath: VMRay.Sample.FileName
      description: File name of the sample.
      type: String
    - contextPath: VMRay.Sample.MD5
      description: MD5 hash of the sample.
      type: String
    - contextPath: VMRay.Sample.SHA1
      description: SHA1 hash of the sample.
      type: String
    - contextPath: VMRay.Sample.SHA256
      description: SHA256 hash of the sample.
      type: String
    - contextPath: VMRay.Sample.SSDeep
      description: ssdeep hash of the sample.
      type: String
    - contextPath: VMRay.Sample.Verdict
      description: Verdict for the sample (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.Severity
      description: Severity of the sample in the submission (Malicious, Suspicious,
        Good, Blacklisted, Whitelisted, Unknown). Deprecated.
      type: String
    - contextPath: VMRay.Sample.Type
      description: File type.
      type: String
    - contextPath: VMRay.Sample.Created
      description: Timestamp of sample creation.
      type: Date
    - contextPath: VMRay.Sample.Classifications
      description: Classifications of the sample.
      type: String
    - contextPath: VMRay.Sample.ChildSampleIDs
      description: List of child sample IDs.
      type: Number
    - contextPath: VMRay.Sample.ParentSampleIDs
      description: List of parent sample IDs.
      type: Number
  - arguments:
    - description: ID of the sample. Can be obtained from the 'VMRay.Sample.ID' output.
      name: sample_id
      required: true
    description: Retrieves threat indicators (VTI).
    name: vmray-get-threat-indicators
    outputs:
    - contextPath: VMRay.ThreatIndicator.AnalysisID
      description: List of connected analysis IDs.
      type: Number
    - contextPath: VMRay.ThreatIndicator.Category
      description: Category of threat indicators.
      type: String
    - contextPath: VMRay.ThreatIndicator.Classification
      description: Classifications of threat indicators.
      type: String
    - contextPath: VMRay.ThreatIndicator.ID
      description: ID of a threat indicator.
      type: Number
    - contextPath: VMRay.ThreatIndicator.Operation
      description: Operation the indicators caused.
      type: String
  - arguments:
    - description: ID of the submission to which to add tags.
      name: submission_id
    - description: ID of the analysis from which to add tags.
      name: analysis_id
    - description: Tag to add.
      name: tag
    description: Adds a tag to an analysis and/or a submission.
    name: vmray-add-tag
  - arguments:
    - description: ID of the analysis from which to delete a tag.
      name: analysis_id
    - description: ID of the submission from which to delete a tag.
      name: submission_id
    - description: Tag to delete.
      name: tag
    description: Deletes tags from an analysis and/or a submission.
    name: vmray-delete-tag
  - arguments:
    - description: ID of the sample.
      name: sample_id
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether all artifacts should be returned or only Indicators of
        Compromise.
      name: all_artifacts
      predefined:
      - "true"
      - "false"
    description: Retrieves Indicators of Compromise for a specified sample.
    name: vmray-get-iocs
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: Domain.Name
      description: The domain name
      type: String
    - contextPath: IP.Address
      description: IP address
      type: String
    - contextPath: URL.Data
      description: The URL
      type: String
    - contextPath: Email.Address
      description: The Email address
      type: String
    - contextPath: File.Path
      description: The full file path.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SSDeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.AnalysisID
      description: IDs of other analyses that contain the domain.
      type: Number
    - contextPath: VMRay.Sample.IOC.Domain.Countries
      description: Countries associated with the domain.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.CountryCodes
      description: ISO 3166-1 two-letter country codes associated with the domain.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.Domain
      description: Domain.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.ID
      description: ID of the domain. (deprecated; is always 0)
      type: Number
    - contextPath: VMRay.Sample.IOC.Domain.IsIOC
      description: Whether this artifact is an Indicator of Compromise (IOC).
      type: Boolean
    - contextPath: VMRay.Sample.IOC.Domain.IOCType
      description: Type of IOC.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.IpAddresses
      description: IP addresses associated with the domain.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.OriginalDomains
      description: Original domains associated with the domain.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.ParentProcesses
      description: Full commandline of processes where the domain was used.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.ParentProcessesNames
      description: Names of processes where the domain was used.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.Protocols
      description: The protocols used for the domain in a request.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.Sources
      description: The sources where the domain was obtained from.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.Type
      description: Type of domain.
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.IOC.EmailAddress.AnalysisID
      description: IDs of other analyses that contain the email address.
      type: Number
    - contextPath: VMRay.Sample.IOC.EmailAddress.Classifications
      description: The classifications of the email address.
      type: String
    - contextPath: VMRay.Sample.IOC.EmailAddress.EmailAddress
      description: The email address.
      type: String
    - contextPath: VMRay.Sample.IOC.EmailAddress.IsIOC
      description: Whether this artifact is an Indicator of Compromise (IOC).
      type: Boolean
    - contextPath: VMRay.Sample.IOC.EmailAddress.IsRecipient
      description: Indicates whether this email address was used as a recipient email.
      type: Boolean
    - contextPath: VMRay.Sample.IOC.EmailAddress.IsSender
      description: Indicates whether this email address was used as a sender email.
      type: Boolean
    - contextPath: VMRay.Sample.IOC.EmailAddress.IOCType
      description: Type of IOC.
      type: String
    - contextPath: VMRay.Sample.IOC.EmailAddress.Subjects
      description: Email subjects this email address was used in.
      type: String
    - contextPath: VMRay.Sample.IOC.EmailAddress.ThreatNames
      description: The threat names of the email address.
      type: String
    - contextPath: VMRay.Sample.IOC.EmailAddress.Type
      description: Type of email address.
      type: String
    - contextPath: VMRay.Sample.IOC.EmailAddress.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.EmailAddress.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.AnalysisID
      description: IDs of other analyses that contain the email.
      type: Number
    - contextPath: VMRay.Sample.IOC.Email.AttachmentTypes
      description: MIME types of attachments found in this email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.Classifications
      description: The classifications of the email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.Hashes.MD5
      description: MD5 of given email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.Hashes.SSDeep
      description: SSDeep of given email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.Hashes.SHA256
      description: SHA256 of given email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.Hashes.SHA1
      description: SHA1 of given email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.IsIOC
      description: Whether this artifact is an Indicator of Compromise (IOC).
      type: Boolean
    - contextPath: VMRay.Sample.IOC.Email.IOCType
      description: Type of IOC.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.NrAttachments
      description: Number of attachments found in the email.
      type: Number
    - contextPath: VMRay.Sample.IOC.Email.NrLinks
      description: Number of links found in the email.
      type: Number
    - contextPath: VMRay.Sample.IOC.Email.Recipients
      description: The email recipients.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.Sender
      description: Sender of the email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.Subject
      description: Subject of the email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.ThreatNames
      description: The threat names of the email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.Type
      description: Type of email.
      type: String
    - contextPath: VMRay.Sample.IOC.Email.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.Email.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.IOC.Filename.AnalysisID
      description: IDs of other analyses that contain the filename.
      type: Number
    - contextPath: VMRay.Sample.IOC.Filename.Categories
      description: The filename categories.
      type: String
    - contextPath: VMRay.Sample.IOC.Filename.Classifications
      description: The classifications of the filename.
      type: String
    - contextPath: VMRay.Sample.IOC.Filename.Filename
      description: The filename.
      type: String
    - contextPath: VMRay.Sample.IOC.Filename.IsIOC
      description: Whether this artifact is an Indicator of Compromise (IOC).
      type: Boolean
    - contextPath: VMRay.Sample.IOC.Filename.IOCType
      description: Type of IOC.
      type: String
    - contextPath: VMRay.Sample.IOC.Filename.Operations
      description: The filename operations that were performed, e.g., access, create,
        read, write, and delete.
      type: String
    - contextPath: VMRay.Sample.IOC.Filename.ThreatNames
      description: The threat names of the filename.
      type: String
    - contextPath: VMRay.Sample.IOC.Filename.Type
      description: Type of filename.
      type: String
    - contextPath: VMRay.Sample.IOC.Filename.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.Filename.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.IOC.File.AnalysisID
      description: IDs of other analyses that contain the file.
      type: Number
    - contextPath: VMRay.Sample.IOC.File.Categories
      description: The file categories.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Classifications
      description: The classifications of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.FileSize
      description: The original size of the file in bytes.
      type: Number
    - contextPath: VMRay.Sample.IOC.File.Filename
      description: Name of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Filenames
      description: All known names of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Hashes.MD5
      description: MD5 hash of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Hashes.SSDeep
      description: SSDeep hash of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Hashes.SHA256
      description: SHA256 hash of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Hashes.SHA1
      description: SHA1 hash of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.ID
      description: ID of the file. (deprecated; is always 0)
      type: Number
    - contextPath: VMRay.Sample.IOC.File.IsIOC
      description: Whether this artifact is an Indicator of Compromise (IOC).
      type: Boolean
    - contextPath: VMRay.Sample.IOC.File.IOCType
      description: Type of IOC.
      type: String
    - contextPath: VMRay.Sample.IOC.File.MIMEType
      description: The MIME type of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Name
      description: Same as Filename.
      type: String
    - contextPath: VMRay.Sample.IOC.File.NormFilename
      description: Normalized name of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Operation
      description: Same as Operations, left in for backwards compatibility.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Operations
      description: The file operations which were performed, e.g., access, create,
        read, write, and delete.
      type: String
    - contextPath: VMRay.Sample.IOC.File.ParentFiles
      description: Files where this file was contained in.
      type: String
    - contextPath: VMRay.Sample.IOC.File.ParentProcesses
      description: Full commandline of processes where the file was referenced.
      type: String
    - contextPath: VMRay.Sample.IOC.File.ParentProcessesNames
      description: Names of processes where the file was referenced.
      type: String
    - contextPath: VMRay.Sample.IOC.File.ResourceURL
      description: URL of where the file was downloaded.
      type: String
    - contextPath: VMRay.Sample.IOC.File.ThreatNames
      description: The threat names of the file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Type
      description: Type of file.
      type: String
    - contextPath: VMRay.Sample.IOC.File.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.File.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.AnalysisID
      description: IDs of other analyses that contain the IP address.
      type: Number
    - contextPath: VMRay.Sample.IOC.IP.Countries
      description: Countries associated with the IP address.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.CountryCodes
      description: ISO 3166-1 two-letter country codes associated with the IP address.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.Domains
      description: Domains associated with the IP address.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.IP
      description: The IP address.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.ID
      description: ID of the IP address. (deprecated; is always 0)
      type: Number
    - contextPath: VMRay.Sample.IOC.IP.IsIOC
      description: Whether this artifact is an Indicator of Compromise (IOC).
      type: Boolean
    - contextPath: VMRay.Sample.IOC.IP.IOCType
      description: Type of IOC.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.Operation
      description: Deprecated, always empty.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.ParentProcesses
      description: Full commandline of processes where the IP address was referenced.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.ParentProcessesNames
      description: Names of processes where the IP address was referenced.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.Protocols
      description: Protocols used in communication with this IP.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.Sources
      description: The sources where the IP address was obtained from.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.Type
      description: Type of IP address.
      type: String
    - contextPath: VMRay.Sample.IOC.IP.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.IP.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.AnalysisID
      description: IDs of other analyses that contain the mutex.
      type: Number
    - contextPath: VMRay.Sample.IOC.Mutex.Classifications
      description: The mutex classifications.
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.ID
      description: ID of the mutex. (deprecated; is always 0)
      type: Number
    - contextPath: VMRay.Sample.IOC.Mutex.IsIOC
      description: Whether this artifact is an Indicator of Compromise (IOC).
      type: Boolean
    - contextPath: VMRay.Sample.IOC.Mutex.IOCType
      description: Type of IOC.
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.Name
      description: Name of the mutex.
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.Operation
      description: Same as Operations, left in for backwards compatibility.
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.Operation
      description: The mutex operations that were performed, e.g., access, create,
        read, write, and delete.
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.ParentProcesses
      description: Full commandline of processes where the mutex was used.
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.ParentProcessesNames
      description: Names of processes where the mutex was used.
      type: Unknown
    - contextPath: VMRay.Sample.IOC.Mutex.ThreatNames
      description: The threat names of the mutex.
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.Type
      description: Type of mutex.
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.AnalysisID
      description: IDs of other analyses that contain the process.
      type: Number
    - contextPath: VMRay.Sample.IOC.Process.Classifications
      description: The process classifications.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.CmdLine
      description: Command line of the process.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.ImageNames
      description: Names of the process executable.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.IsIOC
      description: Whether this artifact is an Indicator of Compromise (IOC).
      type: Boolean
    - contextPath: VMRay.Sample.IOC.Process.IOCType
      description: Type of IOC.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.ParentProcesses
      description: Full commandline of parent processes.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.ParentProcessesNames
      description: Names of parent processes.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.ProcessNames
      description: Names of the processes.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.ThreatNames
      description: The threat names of the process.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.Type
      description: Type of process.
      type: String
    - contextPath: VMRay.Sample.IOC.Process.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.Process.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.AnalysisID
      description: IDs of other analyses that contain the registry key.
      type: Number
    - contextPath: VMRay.Sample.IOC.Registry.Classifications
      description: The registry key classifications.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.ID
      description: ID of the registry key. (deprecated; is always 0)
      type: Number
    - contextPath: VMRay.Sample.IOC.Registry.IsIOC
      description: Whether this artifact is an Indicator of Compromise (IOC).
      type: Boolean
    - contextPath: VMRay.Sample.IOC.Registry.IOCType
      description: Type of IOC.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.Name
      description: The normalized registry key name.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.Operation
      description: Same as Operations, left in for backwards compatibility.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.Operation
      description: The registry operations that were performed, e.g., access, create,
        read, write, and delete.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.ParentProcesses
      description: Full commandline of processes where the registry key was referenced.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.ParentProcessesNames
      description: Names of processes where the registry key was referenced.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.ThreatNames
      description: The threat names of the registry key.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.Type
      description: Type of registry key.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.ValueTypes
      description: The registry key value type.
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.Registry.VerdictReason
      description: Description of the Verdict Reason.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.AnalysisID
      description: IDs of other analyses that contain the given URL.
      type: Number
    - contextPath: VMRay.Sample.IOC.URL.Categories
      description: The URL categories.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.ContentTypes
      description: Content types associated with the URL.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.Countries
      description: Countries associated with the URL.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.CountryCodes
      description: ISO 3166-1 two-letter country codes associated with the URL.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.ID
      description: ID of the URL. (deprecated; is always 0)
      type: Number
    - contextPath: VMRay.Sample.IOC.URL.IPAddresses
      description: IP addresses associated with the URL.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.Methods
      description: Methods of HTTP requests directed at this URL.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.Operation
      description: Deprecated, always empty.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.OriginalURLs
      description: The origin URLs the malware used in the artifact operation.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.ParentFiles
      description: Names of files where the URL was referenced.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.ParentProcesses
      description: Full commandline of processes where the URL was referenced.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.ParentProcessesNames
      description: Names of processes where the URL was referenced.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.Referrers
      description: Other URLs that referred to this URL.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.Source
      description: The sources where the URL was obtained from.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.Type
      description: Type of the URL.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.URL
      description: The URL.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.UserAgents
      description: User agents used to connect to this URL.
      type: String
    - contextPath: VMRay.Sample.IOC.URL.Verdict
      description: Verdict for the artifact (Malicious, Suspicious, Clean, Not Available).
      type: String
    - contextPath: VMRay.Sample.IOC.URL.VerdictReason
      description: Description of the Verdict Reason.
      type: String
  - arguments:
    - description: ID of a job.
      name: job_id
      required: true
    description: Retrieves a job by job ID.
    name: vmray-get-job-by-id
    outputs:
    - contextPath: VMRay.Job.JobID
      description: ID of the job.
      type: Number
    - contextPath: VMRay.Job.SampleID
      description: Sample ID of the job.
      type: Number
    - contextPath: VMRay.Job.SubmissionID
      description: ID of the submission.
      type: Number
    - contextPath: VMRay.Job.MD5
      description: MD5 hash of the sample in the job.
      type: String
    - contextPath: VMRay.Job.SHA1
      description: SHA1 hash of the sample in the job.
      type: String
    - contextPath: VMRay.Job.SHA256
      description: SHA256 hash of the sample in the job.
      type: String
    - contextPath: VMRay.Job.SSDeep
      description: ssdeep hash of the sample in the job.
      type: String
    - contextPath: VMRay.Job.VMName
      description: Name of the virtual machine.
      type: String
    - contextPath: VMRay.Job.VMID
      description: ID of the virtual machine.
      type: Number
    - contextPath: VMRay.Job.Status
      description: Status of the job.
      type: String
  - arguments:
    - description: ID of the analysis from which to retrieve the Summary JSON v2 from
        (analysis ID is returned e.g. from vmray-get-analysis-by-sample).
      name: analysis_id
      required: true
    description: Retrieves the Summary JSON v2 for a specific analysis.
    name: vmray-get-summary
    outputs:
    - contextPath: InfoFile.Name
      description: Filename
      type: string
    - contextPath: InfoFile.EntryID
      description: The EntryID of the Summary JSON v2
      type: string
    - contextPath: InfoFile.Size
      description: The file size of the Summary JSON v2
      type: number
    - contextPath: InfoFile.Info
      description: MIME type of the Summary JSON v2
      type: string
  - arguments:
    - description: Sample ID.
      name: sample_id
      required: true
    deprecated: true
    description: This command performs a function similiar to the 'vmray-get-job-by-sample'
      command.
    name: get_job_sample
  - arguments:
    - description: ID of the sample.
      name: sample_id
      required: true
    deprecated: true
    description: similiar to vmray-get-sample
    name: get_results
  - arguments: []
    deprecated: true
    description: Retrieves a sample using the sample ID. (Deprecated)
    name: upload_sample
  dockerimage: demisto/python3:3.10.6.33415
  runonce: false
  script: |
    register_module_line('vmray', 'start', __line__())
    import requests


    ''' GLOBAL PARAMS '''
    API_KEY = demisto.params().get('api_key') or demisto.params().get('credentials', {}).get('password')
    if not API_KEY:
        raise ValueError('The API Key parameter is required.')
    SERVER = (
        demisto.params()['server'][:-1]
        if (demisto.params()['server'] and demisto.params()['server'].endswith('/'))
        else demisto.params()['server']
    )
    SERVER += '/rest/'
    USE_SSL = not demisto.params().get('insecure', False)
    HEADERS = {'Authorization': 'api_key ' + API_KEY}
    ERROR_FORMAT = 'Error in API call to VMRay [{}] - {}'
    RELIABILITY = demisto.params().get('integrationReliability', DBotScoreReliability.C) or DBotScoreReliability.C

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    # Remove proxy
    PROXIES = handle_proxy()

    ''' HELPER DICTS '''
    SEVERITY_DICT = {
        'malicious': 'Malicious',
        'suspicious': 'Suspicious',
        'not_suspicious': 'Good',
        'blacklisted': 'Blacklisted',
        'whitelisted': 'Whitelisted',
        'unknown': 'Unknown',
        None: 'Unknown',
    }

    VERDICT_DICT = {
        'malicious': 'Malicious',
        'suspicious': 'Suspicious',
        'clean': 'Clean',
        'not_available': 'Not Available',
        None: 'Not Available',
    }

    DBOTSCORE = {
        'Malicious': 3,
        'Suspicious': 2,
        'Clean': 1,
        'Not Available': 0,
    }

    ''' HELPER FUNCTIONS '''


    def is_json(response):
        """Checks if response is jsonable

        Args:
            response (requests.Response):

        Returns:
            bool: true if object is jsonable
        """
        try:
            response.json()
        except ValueError:
            return False
        return True


    def check_id(id_to_check):
        """Checks if parameter id_to_check is a number

        Args:
            id_to_check (int or str or unicode):

        Returns:
            bool: True if is a number, else returns error
        """
        if isinstance(id_to_check, int) or isinstance(id_to_check, str) and id_to_check.isdigit():
            return True
        return_error(ERROR_FORMAT.format(404, 'No such element'))


    def build_errors_string(errors):
        """

        Args:
            errors (list, dict or unicode):

        Returns:
            str: error message
        """
        if isinstance(errors, str):
            return str(errors)
        elif isinstance(errors, list):
            err_str = str()
            for error in errors:
                err_str += error.get('error_msg') + '.\n'
        else:
            err_str = errors.get('error_msg')
        return err_str


    def http_request(method, url_suffix, params=None, files=None, ignore_errors=False, get_raw=False):
        """ General HTTP request.
        Args:
            ignore_errors (bool):
            method: (str) 'GET', 'POST', 'DELETE' 'PUT'
            url_suffix: (str)
            params: (dict)
            files: (tuple, dict)
            get_raw: (bool) return raw data instead of dict

        Returns:
            dict: response json
        """

        def find_error(may_be_error_inside):
            """Function will search for dict with 'errors' or 'error_msg' key

            Args:
                may_be_error_inside: object, any object

            Returns:
                None if no error presents
                Errors list/string if errors inside.
            """
            if isinstance(may_be_error_inside, list):
                for obj in may_be_error_inside:
                    ans = find_error(obj)
                    if ans:
                        return ans
                return None
            if isinstance(may_be_error_inside, dict):
                if 'error_msg' in may_be_error_inside:
                    return may_be_error_inside['error_msg']
                if 'errors' in may_be_error_inside and may_be_error_inside.get('errors'):
                    return may_be_error_inside['errors']
                for value in may_be_error_inside.values():
                    err_r = find_error(value)
                    if err_r:
                        return err_r
            return None

        url = SERVER + url_suffix
        r = requests.request(
            method, url, params=params, headers=HEADERS, files=files, verify=USE_SSL, proxies=PROXIES
        )
        # Handle errors
        try:
            if r.status_code in {405, 401}:
                return_error(ERROR_FORMAT.format(r.status_code, 'Token may be invalid'))
            elif not get_raw and not is_json(r):
                raise ValueError
            response = r.json() if not get_raw else r.text
            if r.status_code not in {200, 201, 202, 204} and not ignore_errors:
                if get_raw and isinstance(response, str):
                    # this might be json even if get_raw is True because the API will return errors as json
                    try:
                        response = json.loads(response)
                    except ValueError:
                        pass
                err = find_error(response)
                if not err:
                    err = r.text
                return_error(ERROR_FORMAT.format(r.status_code, err))

            err = find_error(response)
            if err:
                if "no jobs were created" in build_errors_string(err):
                    err_message = err[0].get("error_msg") + '. There is a possibility this file has been analyzed ' \
                                                            'before. Please change the Analysis Caching mode for this ' \
                                                            'API key to something other than "Legacy" in the VMRay ' \
                                                            'Web Interface.'
                    err[0]['error_msg'] = err_message
                return_error(ERROR_FORMAT.format(r.status_code, err))
            return response
        except ValueError:
            # If no JSON is present, must be an error that can't be ignored
            return_error(ERROR_FORMAT.format(r.status_code, r.text))


    def dbot_score_by_hash(data):
        """Gets a dict containing MD5/SHA1/SHA256/SSDeep and return dbotscore

        Args:
            data: (dict)

        Returns:
            list: dbot scores
        """
        hashes = ['MD5', 'SHA256', 'SHA1', 'SSDeep']
        scores = list()
        for hash_type in hashes:
            if hash_type in data:
                scores.append(
                    {
                        'Indicator': data.get(hash_type),
                        'Type': 'hash',
                        'Vendor': 'VMRay',
                        'Score': DBOTSCORE.get(data.get('Verdict', 0)),
                        'Reliability': RELIABILITY
                    }
                )
        return scores


    def build_job_data(data):
        """

        Args:
            data: any kind of object.

        Returns:
            list: list of jobs
        """

        def build_entry(entry_data):
            entry = dict()
            entry['JobID'] = entry_data.get('job_id')
            entry['SampleID'] = entry_data.get('job_sample_id')
            entry['SubmissionID'] = entry_data.get('job_submission_id')
            entry['MD5'] = entry_data.get('job_sample_md5')
            entry['SHA1'] = entry_data.get('job_sample_sha1')
            entry['SHA256'] = entry_data.get('job_sample_sha256')
            entry['SSDeep'] = entry_data.get('job_sample_ssdeep')
            entry['VMName'] = entry_data.get('job_vm_name')
            entry['VMID'] = entry_data.get('job_vm_id')
            entry['Status'] = entry_data.get('job_status')
            return entry

        jobs_list = list()
        if isinstance(data, list):
            for item in data:
                jobs_list.append(build_entry(item))
        elif isinstance(data, dict):
            jobs_list = build_entry(data)
        return jobs_list


    def build_finished_job(job_id, sample_id):
        entry = dict()
        entry['JobID'] = job_id
        entry['SampleID'] = sample_id
        entry['Status'] = 'Finished/NotExists'
        return entry


    def build_analysis_data(analyses):
        """

        Args:
            analyses: (dict) of analysis

        Returns:
            dict: formatted entry context
        """
        entry_context = dict()
        entry_context['VMRay.Analysis(val.AnalysisID === obj.AnalysisID)'] = [
            {
                'AnalysisID': analysis.get('analysis_id'),
                'AnalysisURL': analysis.get('analysis_webif_url'),
                'SampleID': analysis.get('analysis_sample_id'),
                'Verdict': VERDICT_DICT.get(analysis.get('analysis_verdict')),
                'VerdictReason': analysis.get('analysis_verdict_reason_description'),
                'Severity': SEVERITY_DICT.get(analysis.get('analysis_severity')),
                'JobCreated': analysis.get('analysis_job_started'),
                'SHA1': analysis.get('analysis_sample_sha1'),
                'MD5': analysis.get('analysis_sample_md5'),
                'SHA256': analysis.get('analysis_sample_sha256'),
            }
            for analysis in analyses
        ]

        scores = list()  # type: list
        for analysis in entry_context:
            scores.extend(dbot_score_by_hash(analysis))
        entry_context[outputPaths['dbotscore']] = scores

        return entry_context


    def build_upload_params():
        """Builds params for upload_file

        Returns:
            dict: params
        """
        # additional params
        doc_pass = demisto.args().get('document_password')
        arch_pass = demisto.args().get('archive_password')
        sample_type = demisto.args().get('sample_type')
        shareable = demisto.args().get('shareable')
        max_jobs = demisto.args().get('max_jobs')
        tags = demisto.args().get('tags')

        params = dict()
        if doc_pass:
            params['document_password'] = doc_pass
        if arch_pass:
            params['archive_password'] = arch_pass
        if sample_type:
            params['sample_type'] = sample_type

        params['shareable'] = shareable == 'true'

        if max_jobs:
            if isinstance(max_jobs, str) and max_jobs.isdigit() or isinstance(max_jobs, int):
                params['max_jobs'] = int(max_jobs)
            else:
                return_error('max_jobs arguments isn\'t a number')
        if tags:
            params['tags'] = tags
        return params


    def test_module():
        """Simple get request to see if connected
        """
        response = http_request('GET', 'analysis?_limit=1')
        demisto.results('ok') if response.get('result') == 'ok' else return_error(
            'Can\'t authenticate: {}'.format(response)
        )


    def submit(params, files=None):
        """Submit a file/URL to VMRay Platform

        Args:
            params: (dict)
            files: (tuple, dict)

        Returns:
            dict: response
        """

        suffix = 'sample/submit'
        results = http_request('POST', url_suffix=suffix, params=params, files=files)
        return results


    def build_submission_data(raw_response, type_):
        """Process a submission response from VMRay Platform

        Args:
            raw_response: (dict)
            type_: (str)
        """

        data = raw_response.get('data')

        jobs_list = []
        jobs = data.get('jobs', [])
        for job in jobs:
            if isinstance(job, dict):
                job_entry = dict()
                job_entry['JobID'] = job.get('job_id')
                job_entry['Created'] = job.get('job_created')
                job_entry['SampleID'] = job.get('job_sample_id')
                job_entry['VMName'] = job.get('job_vm_name')
                job_entry['VMID'] = job.get('job_vm_id')
                job_entry['JobRuleSampleType'] = job.get('job_jobrule_sampletype')
                jobs_list.append(job_entry)

        samples_list = []
        samples = data.get('samples', [])
        for sample in samples:
            if isinstance(sample, dict):
                sample_entry = dict()
                sample_entry['SampleID'] = sample.get('sample_id')
                sample_entry['SampleURL'] = sample.get('sample_webif_url')
                sample_entry['Created'] = sample.get('sample_created')
                sample_entry['FileName'] = sample.get('submission_filename')
                sample_entry['FileSize'] = sample.get('sample_filesize')
                sample_entry['SSDeep'] = sample.get('sample_ssdeephash')
                sample_entry['SHA1'] = sample.get('sample_sha1hash')
                samples_list.append(sample_entry)

        submissions_list = []
        submissions = data.get('submissions', [])
        for submission in submissions:
            if isinstance(submission, dict):
                submission_entry = dict()
                submission_entry['SubmissionID'] = submission.get('submission_id')
                submission_entry['SubmissionURL'] = submission.get('submission_webif_url')
                submission_entry['SampleID'] = submission.get('submission_sample_id')
                submissions_list.append(submission_entry)

        entry_context = dict()
        entry_context['VMRay.Job(val.JobID === obj.JobID)'] = jobs_list
        entry_context['VMRay.Sample(val.SampleID === obj.SampleID)'] = samples_list
        entry_context[
            'VMRay.Submission(val.SubmissionID === obj.SubmissionID)'
        ] = submissions_list

        table = {
            'Jobs ID': [job.get('JobID') for job in jobs_list],
            'Samples ID': [sample.get('SampleID') for sample in samples_list],
            'Submissions ID': [
                submission.get('SubmissionID') for submission in submissions_list
            ],
            'Sample URL': [sample.get('SampleURL') for sample in samples_list],
        }
        human_readable = tableToMarkdown(
            type_ + ' submitted to VMRay',
            t=table,
            headers=['Jobs ID', 'Samples ID', 'Submissions ID', 'Sample URL'],
        )

        return_outputs(
            readable_output=human_readable, outputs=entry_context, raw_response=raw_response
        )


    def encode_file_name(file_name):
        """
        encodes the file name - i.e ignoring non ASCII chars and removing backslashes
        Args:
            file_name (str): name of the file
        Returns: encoded file name
        """
        file_name = file_name.replace('\\', '')
        return file_name.encode('ascii', 'ignore')


    def upload_sample_command():
        """Uploads a file to vmray
        """
        # Preserve BC
        file_id = (
            demisto.args().get('entry_id')
            if demisto.args().get('entry_id')
            else demisto.args().get('file_id')
        )
        params = build_upload_params()

        file_obj = demisto.getFilePath(file_id)
        # Ignoring non ASCII
        file_name = encode_file_name(file_obj['name'])
        file_path = file_obj['path']
        with open(file_path, 'rb') as f:
            files = {'sample_file': (file_name, f)}
            # Request call
            raw_response = submit(params, files=files)
            return build_submission_data(raw_response, "File")


    def upload_url_command():
        """upload a URL to VMRay
        """
        args = demisto.args()
        url = args.get('url')

        if isinstance(url, str):
            url = str(url)

        params = build_upload_params()
        params['sample_url'] = url
        raw_response = submit(params)

        return build_submission_data(raw_response, "URL")


    def get_analysis(sample, params=None):
        """Uploading sample to vmray

        Args:
            sample (str): sample id
            params (dict): dict of params

        Returns:
            dict: response
        """
        suffix = 'analysis/sample/{}'.format(sample)
        response = http_request('GET', suffix, params=params)
        return response


    def get_analysis_command():
        sample_id = demisto.args().get('sample_id')
        check_id(sample_id)
        limit = demisto.args().get('limit')
        params = {'_limit': limit}
        raw_response = get_analysis(sample_id, params)
        data = raw_response.get('data')
        if data:
            entry_context = build_analysis_data(data)
            human_readable = tableToMarkdown(
                'Analysis results from VMRay for ID {}:'.format(sample_id),
                entry_context.get('VMRay.Analysis(val.AnalysisID === obj.AnalysisID)'),
                headers=['AnalysisID', 'SampleID', 'Verdict', 'AnalysisURL']
            )
            return_outputs(human_readable, entry_context, raw_response=raw_response)
        else:
            return_outputs('#### No analysis found for sample id {}'.format(sample_id), None)


    def get_submission(submission_id):
        """

        Args:
            submission_id (str): if of submission

        Returns:
            dict: response
        """
        suffix = 'submission/{}'.format(submission_id)
        response = http_request('GET', url_suffix=suffix)
        return response


    def get_submission_command():
        submission_id = demisto.args().get('submission_id')
        check_id(submission_id)
        demisto.info("Getting submission for {}".format(submission_id))

        try:
            raw_response = get_submission(submission_id)
        except Exception as err:
            demisto.error(str(err))
            raise err

        data = raw_response.get('data')
        if data:
            # Build entry
            entry = dict()
            entry['IsFinished'] = data.get('submission_finished')
            entry['HasErrors'] = data.get('submission_has_errors')
            entry['SubmissionID'] = data.get('submission_id')
            entry['SubmissionURL'] = data.get('submission_webif_url')
            entry['MD5'] = data.get('submission_sample_md5')
            entry['SHA1'] = data.get('submission_sample_sha1')
            entry['SHA256'] = data.get('submission_sample_sha256')
            entry['SSDeep'] = data.get('submission_sample_ssdeep')
            entry['Verdict'] = VERDICT_DICT.get(data.get('submission_verdict'))
            entry['VerdictReason'] = data.get('submission_verdict_reason_description')
            entry['Severity'] = SEVERITY_DICT.get(data.get('submission_severity'))
            entry['SampleID'] = data.get('submission_sample_id')
            scores = dbot_score_by_hash(entry)

            entry_context = {
                'VMRay.Submission(val.SubmissionID === obj.SubmissionID)': entry,
                outputPaths.get('dbotscore'): scores,
            }

            human_readable = tableToMarkdown(
                'Submission results from VMRay for ID {} with verdict of {}'.format(
                    submission_id, entry.get('Verdict', 'Unknown')
                ),
                entry,
                headers=[
                    'IsFinished',
                    'Verdict',
                    'HasErrors',
                    'MD5',
                    'SHA1',
                    'SHA256',
                    'SSDeep',
                    'SubmissionURL',
                ],
            )

            return_outputs(human_readable, entry_context, raw_response=raw_response)
        else:
            return_outputs(
                'No submission found in VMRay for submission id: {}'.format(submission_id),
                {},
            )


    def get_sample(sample_id):
        """building http request for get_sample_command

        Args:
            sample_id (str, int):

        Returns:
            dict: data from response
        """
        suffix = 'sample/{}'.format(sample_id)
        response = http_request('GET', suffix)
        return response


    def create_sample_entry(data):
        """Construct output dict from api response data

        Args:
            data (dict):

        Returns:
            dict: entry

        """
        entry = dict()
        entry['SampleID'] = data.get('sample_id')
        entry['SampleURL'] = data.get('sample_webif_url')
        entry['FileName'] = data.get('sample_filename')
        entry['MD5'] = data.get('sample_md5hash')
        entry['SHA1'] = data.get('sample_sha1hash')
        entry['SHA256'] = data.get('sample_sha256hash')
        entry['SSDeep'] = data.get('sample_ssdeephash')
        entry['Verdict'] = VERDICT_DICT.get(data.get('sample_verdict'))
        entry['VerdictReason'] = data.get('sample_verdict_reason_description')
        entry['Severity'] = SEVERITY_DICT.get(data.get('sample_severity'))
        entry['Type'] = data.get('sample_type')
        entry['Created'] = data.get('sample_created')
        entry['Classification'] = data.get('sample_classifications')
        entry['ChildSampleIDs'] = data.get('sample_child_sample_ids')
        entry['ParentSampleIDs'] = data.get('sample_parent_sample_ids')

        return entry


    def get_sample_command():
        sample_id = demisto.args().get('sample_id')
        check_id(sample_id)

        # query API
        raw_response = get_sample(sample_id)

        # build response dict
        data = raw_response.get('data')
        entry = create_sample_entry(data)
        scores = dbot_score_by_hash(entry)
        entry_context = {
            'VMRay.Sample(var.SampleID === obj.SampleID)': entry,
            outputPaths.get('dbotscore'): scores,
        }

        human_readable = tableToMarkdown(
            'Results for sample id: {} with verdict {}'.format(
                entry.get('SampleID'), entry.get('Verdict', 'Unknown')
            ),
            entry,
            headers=['FileName', 'Type', 'MD5', 'SHA1', 'SHA256', 'SSDeep', 'SampleURL'],
        )
        return_outputs(human_readable, entry_context, raw_response=raw_response)


    def get_sample_by_hash(hash_type, hash):
        """building http request for get_sample_by_hash_command

        Args:
            hash_type (str)
            hash (str)

        Returns:
            list[dict]: list of matching samples
        """
        suffix = 'sample/{}/{}'.format(hash_type, hash)
        response = http_request('GET', suffix)
        return response


    def get_sample_by_hash_command():
        hash = demisto.args().get('hash').strip()

        hash_type_lookup = {
            32: "md5",
            40: "sha1",
            64: "sha256"
        }
        hash_type = hash_type_lookup.get(len(hash))
        if hash_type is None:
            error_string = " or ".join("{} ({})".format(len_, type_) for len_, type_ in hash_type_lookup.items())
            return_error('Invalid hash provided, must be of length {}. Provided hash had length {}.'
                         .format(error_string, len(hash)))

        # query API
        raw_response = get_sample_by_hash(hash_type, hash)

        # build response dict
        samples = raw_response.get('data')

        if samples:
            # VMRay outputs
            entry_context = dict()
            context_key = 'VMRay.Sample(val.{} === obj.{})'.format(hash.upper(), hash.upper())
            entry_context[context_key] = [
                create_sample_entry(sample)
                for sample in samples
            ]

            # DBotScore output
            scores = list()  # type: list
            for sample in entry_context[context_key]:
                scores += dbot_score_by_hash(sample)
            entry_context[outputPaths['dbotscore']] = scores

            # Indicator output
            # just use the first sample that is returned by the API for now
            entry = entry_context[context_key][0]
            file = Common.File(
                None,
                md5=entry['MD5'],
                sha1=entry['SHA1'],
                sha256=entry['SHA256'],
                ssdeep=entry['SSDeep'],
                name=entry['FileName']
            )
            entry_context.update(file.to_context())

            human_readable = tableToMarkdown(
                'Results for {} hash {}:'.format(hash_type, hash),
                entry_context[context_key],
                headers=['SampleID', 'FileName', 'Type', 'Verdict', 'SampleURL'],
            )
            return_outputs(human_readable, entry_context, raw_response=raw_response)
        else:
            return_outputs(
                'No samples found for {} hash {}'.format(hash_type, hash),
                {},
            )


    def get_job(job_id, sample_id):
        """
        Args:
            sample_id (str):
            job_id (str):
        Returns:
            dict of response, if not exists returns:
            {
                'error_msg': 'No such element'
                'result': 'error'
            }
        """
        suffix = (
            'job/{}'.format(job_id)
            if job_id
            else 'job/sample/{}'.format(sample_id)
        )
        response = http_request('GET', suffix, ignore_errors=True)
        return response


    def get_job_command():
        job_id = demisto.args().get('job_id')
        sample_id = demisto.args().get('sample_id')
        if sample_id:
            check_id(sample_id)
        else:
            check_id(job_id)

        vmray_id = job_id if job_id else sample_id
        title = 'job' if job_id else 'sample'

        raw_response = get_job(job_id=job_id, sample_id=sample_id)
        data = raw_response.get('data')
        if not data or raw_response.get('result') == 'error':
            entry = build_finished_job(job_id=job_id, sample_id=sample_id)
            human_readable = '#### Couldn\'t find a job for the {}: {}. Either the job completed, or does not exist.' \
                .format(title, vmray_id)
        else:
            entry = build_job_data(data)
            sample = entry[0] if isinstance(entry, list) else entry
            human_readable = tableToMarkdown(
                'Job results for {} id: {}'.format(title, vmray_id),
                sample,
                headers=['JobID', 'SampleID', 'VMName', 'VMID'],
            )

        entry_context = {
            'VMRay.Job(val.JobID === obj.JobID && val.SampleID === obj.SampleID)': entry
        }
        return_outputs(human_readable, entry_context, raw_response=raw_response)


    def get_threat_indicators(sample_id):
        """

        Args:
            sample_id (str):

        Returns:
            dict: response
        """
        suffix = 'sample/{}/threat_indicators'.format(sample_id)
        response = http_request('GET', suffix).get('data')
        return response


    def get_threat_indicators_command():
        sample_id = demisto.args().get('sample_id')
        check_id(sample_id)
        raw_response = get_threat_indicators(sample_id)
        data = raw_response.get('threat_indicators')

        # Build Entry Context
        if data and isinstance(data, list):
            entry_context_list = list()
            for indicator in data:
                entry = dict()
                entry['AnalysisID'] = indicator.get('analysis_ids')
                entry['Category'] = indicator.get('category')
                entry['Classification'] = indicator.get('classifications')
                entry['ID'] = indicator.get('id')
                entry['Operation'] = indicator.get('operation')
                entry_context_list.append(entry)

            human_readable = tableToMarkdown(
                'Threat indicators for sample ID: {}:'.format(
                    sample_id
                ),
                entry_context_list,
                headers=['ID', 'AnalysisID', 'Category', 'Classification', 'Operation'],
            )

            entry_context = {'VMRay.ThreatIndicator(obj.ID === val.ID)': entry_context_list}
            return_outputs(
                human_readable, entry_context, raw_response={'threat_indicators': data}
            )
        else:
            return_outputs(
                'No threat indicators for sample ID: {}'.format(sample_id),
                {},
                raw_response=raw_response,
            )


    def post_tags_to_analysis(analysis_id, tag):
        """

        Args:
            analysis_id (str):
            tag (str):

        Returns:
            dict:
        """
        suffix = 'analysis/{}/tag/{}'.format(analysis_id, tag)
        response = http_request('POST', suffix)
        return response


    def post_tags_to_submission(submission_id, tag):
        """

        Args:
            submission_id (str):
            tag (str):

        Returns:
            dict:

        """
        suffix = 'submission/{}/tag/{}'.format(submission_id, tag)
        response = http_request('POST', suffix)
        return response


    def post_tags():
        analysis_id = demisto.args().get('analysis_id')
        submission_id = demisto.args().get('submission_id')
        tag = demisto.args().get('tag')
        if not submission_id and not analysis_id:
            return_error('No submission ID or analysis ID has been provided')
        if analysis_id:
            analysis_status = post_tags_to_analysis(analysis_id, tag)
            if analysis_status.get('result') == 'ok':
                return_outputs(
                    'Tags: {} has been added to analysis: {}'.format(tag, analysis_id),
                    {},
                    raw_response=analysis_status,
                )
        if submission_id:
            submission_status = post_tags_to_submission(submission_id, tag)
            if submission_status.get('result') == 'ok':
                return_outputs(
                    'Tags: {} has been added to submission: {}'.format(tag, submission_id),
                    {},
                    raw_response=submission_status,
                )


    def delete_tags_from_analysis(analysis_id, tag):
        suffix = 'analysis/{}/tag/{}'.format(analysis_id, tag)
        response = http_request('DELETE', suffix)
        return response


    def delete_tags_from_submission(submission_id, tag):
        suffix = 'submission/{}/tag/{}'.format(submission_id, tag)
        response = http_request('DELETE', suffix)
        return response


    def delete_tags():
        analysis_id = demisto.args().get('analysis_id')
        submission_id = demisto.args().get('submission_id')
        tag = demisto.args().get('tag')
        if not submission_id and not analysis_id:
            return_error('No submission ID or analysis ID has been provided')
        if submission_id:
            submission_status = delete_tags_from_submission(submission_id, tag)
            if submission_status.get('result') == 'ok':
                return_outputs(
                    'Tags: {} has been removed from submission: {}'.format(tag, submission_id),
                    {},
                    raw_response=submission_status,
                )
        if analysis_id:
            analysis_status = delete_tags_from_analysis(analysis_id, tag)
            if analysis_status.get('result') == 'ok':
                return_outputs(
                    'Tags: {} has been removed from analysis: {}'.format(tag, analysis_id),
                    {},
                    raw_response=analysis_status,
                )


    def get_iocs(sample_id, all_artifacts):
        """

        Args:
            sample_id (str):

        Returns:
            dict: response
        """
        suffix = 'sample/{}/iocs'.format(sample_id)
        if all_artifacts:
            suffix += '?all_artifacts=true'
        response = http_request('GET', suffix)
        return response


    def get_iocs_command():
        def get_hashed(lst):
            """

            Args:
                lst (List[dict]): list of hashes attributes

            Returns:
                List[dict]:list of hashes attributes in demisto's favor
            """
            hashes_dict = {
                'MD5': 'md5_hash',
                'SHA1': 'sha1_hash',
                'SHA256': 'sha256_hash',
                'SSDeep': 'ssdeep_hash'
            }
            return [
                {k: hashes.get(v) for k, v in hashes_dict.items()}
                for hashes in lst
            ]

        sample_id = demisto.args().get('sample_id')
        check_id(sample_id)
        all_artifacts = demisto.args().get('all_artifacts', 'false').lower() == 'true'
        raw_response = get_iocs(sample_id, all_artifacts)
        data = raw_response.get('data', {}).get('iocs', {})

        command_results_list = []

        indicator_types = {
            # mapping of
            # VMRay artifact type -> XSOAR score type,      Indicator class, Main value key, Headers
            'Domain': (DBotScoreType.DOMAIN, Common.Domain, 'Domain', ['OriginalDomains', 'Countries']),  # noqa: E241, E501
            'EmailAddress': (DBotScoreType.EMAIL, Common.EMAIL, 'EmailAddress', ['IsRecipient', 'IsSender', 'Subjects']),
            # noqa: E241, E501
            'Email': (None, None, 'Subject', ['Subject', 'Sender', 'Recipients',  # noqa: E241, E501
                                              'NrAttachments', 'NrLinks']),
            'Filename': (None, None, 'Filename', ['Operations']),  # noqa: E241
            'File': (DBotScoreType.FILE, None, 'Filename', ['Filenames', 'MD5', 'SHA1', 'SHA256',  # noqa: E241, E501
                                                            'Operations']),
            'IP': (DBotScoreType.IP, Common.IP, 'IP', ['Domains', 'Countries', 'Protocols']),  # noqa: E241, E501
            'Mutex': (None, None, 'Name', ['Operations', 'ParentProcessesNames']),  # noqa: E241, E501
            'Process': (None, None, 'ProcessNames', ['CmdLine']),  # noqa: E241
            'Registry': (None, None, 'Name', ['ValueTypes', 'Operations',  # noqa: E241, E501
                                              'ParentProcessesNames']),
            'URL': (DBotScoreType.URL, Common.URL, 'URL', ['OriginalURLs', 'Categories',  # noqa: E241, E501
                                                           'Countries', 'Methods', 'IPAddresses',
                                                           'ParentProcessesNames']),
        }

        # this will be extended with every call to generate_results
        # we need to keep the state and always add new items to it, so that new results don't replace information from
        # older ones
        context_output = {
            'SampleID': sample_id,
            'IOC': {}
        }
        artifact_type = 'artifact' if all_artifacts else 'IOC'

        # helper function to generate the CommandResults objects from the IOC information
        def generate_results(vmray_type, objects):
            res = []
            dbot_score_type, indicator_class, key_field, headers = indicator_types[vmray_type]
            for object in objects:
                key_value = object[key_field]
                indicator = None
                if dbot_score_type == DBotScoreType.FILE:
                    # special handing for File indicators since they need a hash as the indicator...
                    hashes = object.get('Hashes', [{}])[0]
                    dbot_score = Common.DBotScore(
                        indicator=hashes.get('MD5'),
                        indicator_type=dbot_score_type,
                        integration_name='VMRay',
                        score=DBOTSCORE.get(object['Verdict'], 0)
                    )
                    # ... and have multiple parameters
                    indicator = Common.File(
                        dbot_score,
                        path=key_value,
                        size=object.get('FileSize'),
                        md5=hashes.get('MD5'),
                        sha1=hashes.get('SHA1'),
                        sha256=hashes.get('SHA256'),
                        ssdeep=hashes.get('SSDeep'),
                        file_type=object.get('MIMEType')
                    )
                elif dbot_score_type is not None and indicator_class:
                    # Generic handling for IOCs which have a corresponding Indicator type in XSOAR
                    dbot_score = Common.DBotScore(
                        indicator=key_value,
                        indicator_type=dbot_score_type,
                        integration_name='VMRay',
                        score=DBOTSCORE.get(object['Verdict'], 0)
                    )
                    # first argument must always be the "main" value and second arg the score
                    indicator = indicator_class(key_value, dbot_score)

                # fields that should be shown in human-readable output
                table_headers = [key_field, 'IsIOC'] + headers + ['Verdict', 'VerdictReason']

                # add IOC to the final context output
                if vmray_type in context_output['IOC']:
                    context_output['IOC'][vmray_type].append(object)
                else:
                    context_output['IOC'][vmray_type] = [object]

                if dbot_score_type == DBotScoreType.FILE:
                    # for files we put the hashes manually in the readable output
                    info = object.copy()
                    info.update(info.get('Hashes', [{}])[0])
                else:
                    info = object

                try:
                    # tableToMarkdown sometimes chokes on unicode input
                    readable_output = tableToMarkdown(vmray_type + " " + artifact_type, info, headers=table_headers,
                                                      removeNull=True)
                except UnicodeEncodeError:
                    readable_output = " "

                res.append(CommandResults(
                    outputs_prefix='VMRay.Sample',
                    outputs_key_field='SampleID',
                    outputs=context_output,
                    readable_output=readable_output,
                    indicator=indicator
                ))
            return res

        domains = data.get('domains', [])
        command_results_list.append(generate_results('Domain', [{
            'AnalysisID': domain.get('analysis_ids'),
            'Countries': domain.get('countries'),
            'CountryCodes': domain.get('country_codes'),
            'Domain': domain.get('domain'),
            'ID': 0,  # deprecated
            'IsIOC': domain.get('ioc'),
            'IOCType': domain.get('ioc_type'),
            'IpAddresses': domain.get('ip_addresses'),
            'OriginalDomains': domain.get('original_domains'),
            'ParentProcesses': domain.get('parent_processes'),
            'ParentProcessesNames': domain.get('parent_processes_names'),
            'Protocols': domain.get('protocols'),
            'Sources': domain.get('sources'),
            'Type': domain.get('type'),
            'Verdict': VERDICT_DICT.get(domain.get('verdict')),
            'VerdictReason': domain.get('verdict_reason'),
        } for domain in domains if domain.get('domain')]))

        email_addresses = data.get('email_addresses', [])
        command_results_list.append(generate_results('EmailAddress', [{
            'AnalysisID': email_address.get('analysis_ids'),
            'Classifications': email_address.get('classifications'),
            'EmailAddress': email_address.get('email_address'),
            'IsIOC': email_address.get('ioc'),
            'IsRecipient': email_address.get('recipient'),
            'IsSender': email_address.get('sender'),
            'IOCType': email_address.get('ioc_type'),
            'Subjects': email_address.get('subjects'),
            'ThreatNames': email_address.get('threat_names'),
            'Type': email_address.get('type'),
            'Verdict': VERDICT_DICT.get(email_address.get('verdict')),
            'VerdictReason': email_address.get('verdict_reason'),
        } for email_address in email_addresses if email_address.get('email_address')]))

        emails = data.get('emails', [])
        command_results_list.append(generate_results('Email', [{
            'AnalysisID': email.get('analysis_ids'),
            'AttachmentTypes': email.get('attachment_types'),
            'Classifications': email.get('classifications'),
            'Hashes': get_hashed(email.get('hashes')),
            'IsIOC': email.get('ioc'),
            'IOCType': email.get('ioc_type'),
            'NrAttachments': email.get('nr_attachments'),
            'NrLinks': email.get('nr_links'),
            'Recipients': email.get('recipients'),
            'Sender': email.get('sender'),
            'Subject': email.get('subject'),
            'ThreatNames': email.get('threat_names'),
            'Type': email.get('type'),
            'Verdict': VERDICT_DICT.get(email.get('verdict')),
            'VerdictReason': email.get('verdict_reason'),
        } for email in emails]))

        filenames = data.get('filenames', [])
        command_results_list.append(generate_results('Filename', [{
            'AnalysisID': filename.get('analysis_ids'),
            'Categories': filename.get('categories'),
            'Classifications': filename.get('classifications'),
            'Filename': filename.get('filename'),
            'IsIOC': filename.get('ioc'),
            'IOCType': filename.get('ioc_type'),
            'Operations': filename.get('operations'),
            'ThreatNames': filename.get('threat_names'),
            'Type': filename.get('type'),
            'Verdict': VERDICT_DICT.get(filename.get('verdict')),
            'VerdictReason': filename.get('verdict_reason'),
        } for filename in filenames if filename.get('filename')]))

        files = data.get('files', [])
        command_results_list.append(generate_results('File', [{
            'AnalysisID': file.get('analysis_ids'),
            'Categories': file.get('categories'),
            'Classifications': file.get('classifications'),
            'FileSize': file.get('file_size'),
            'Filename': file.get('filename'),
            'Filenames': file.get('filenames'),
            'Hashes': get_hashed(file.get('hashes')),
            'ID': 0,  # deprecated
            'IsIOC': file.get('ioc'),
            'IOCType': file.get('ioc_type'),
            'MIMEType': file.get('mime_type'),
            'Name': file.get('filename'),  # for backwards compatibility
            'NormFilename': file.get('norm_filename'),
            'Operation': file.get('operations'),  # typo
            'Operations': file.get('operations'),
            'ParentFiles': file.get('parent_files'),
            'ParentProcesses': file.get('parent_processes'),
            'ParentProcessesNames': file.get('parent_processes_names'),
            'ResourceURL': file.get('resource_url'),
            'ThreatNames': file.get('threat_names'),
            'Type': file.get('type'),
            'Verdict': VERDICT_DICT.get(file.get('verdict')),
            'VerdictReason': file.get('verdict_reason'),
        } for file in files]))

        ips = data.get('ips', [])
        command_results_list.append(generate_results('IP', [{
            'AnalysisID': ip.get('analysis_ids'),
            'Country': ip.get('country'),
            'CountryCode': ip.get('country_code'),
            'Domains': ip.get('domains'),
            'IP': ip.get('ip_address'),
            'ID': 0,  # deprecated
            'IsIOC': ip.get('ioc'),
            'IOCType': ip.get('ioc_type'),
            'Operation': None,  # deprecated
            'ParentProcesses': ip.get('parent_processes'),
            'ParentProcessesNames': ip.get('parent_processes_names'),
            'Protocols': ip.get('protocols'),
            'Sources': ip.get('sources'),
            'Type': ip.get('type'),
            'Verdict': VERDICT_DICT.get(ip.get('verdict')),
            'VerdictReason': ip.get('verdict_reason'),
        } for ip in ips if ip.get('ip_address')]))

        mutexes = data.get('mutexes', [])
        command_results_list.append(generate_results('Mutex', [{
            'AnalysisID': mutex.get('analysis_ids'),
            'Classifications': mutex.get('classifications'),
            'ID': 0,  # deprecated
            'IsIOC': mutex.get('ioc'),
            'IOCType': mutex.get('ioc_type'),
            'Name': mutex.get('mutex_name'),
            'Operation': mutex.get('operations'),  # typo
            'Operations': mutex.get('operations'),
            'ParentProcesses': mutex.get('parent_processes'),
            'ParentProcessesNames': mutex.get('parent_processes_names'),
            'ThreatNames': mutex.get('threat_names'),
            'Type': mutex.get('type'),
            'Verdict': VERDICT_DICT.get(mutex.get('verdict')),
            'VerdictReason': mutex.get('verdict_reason'),
        } for mutex in mutexes if mutex.get('mutex_name')]))

        processes = data.get('processes', [])
        command_results_list.append(generate_results('Process', [{
            'AnalysisID': process.get('analysis_ids'),
            'Classifications': process.get('classifications'),
            'CmdLine': process.get('cmd_line'),
            'ImageNames': process.get('image_names'),
            'IsIOC': process.get('ioc'),
            'IOCType': process.get('ioc_type'),
            'ParentProcesses': process.get('parent_processes'),
            'ParentProcessesNames': process.get('parent_processes_names'),
            'ProcessNames': process.get('process_names'),
            'ThreatNames': process.get('threat_names'),
            'Type': process.get('type'),
            'Verdict': VERDICT_DICT.get(process.get('verdict')),
            'VerdictReason': process.get('verdict_reason'),
        } for process in processes if process.get('process_names')]))

        registry = data.get('registry', [])
        command_results_list.append(generate_results('Registry', [{
            'AnalysisID': reg.get('analysis_ids'),
            'Classifications': reg.get('classifications'),
            'ID': 0,  # deprecated
            'IsIOC': reg.get('ioc'),
            'IOCType': reg.get('ioc_type'),
            'Name': reg.get('reg_key_name'),
            'Operation': reg.get('operations'),  # typo
            'Operations': reg.get('operations'),
            'ParentProcesses': reg.get('parent_processes'),
            'ParentProcessesNames': reg.get('parent_processes_names'),
            'ThreatNames': reg.get('threat_names'),
            'Type': reg.get('type'),
            'ValueTypes': reg.get('reg_key_value_types'),
            'Verdict': VERDICT_DICT.get(reg.get('verdict')),
            'VerdictReason': reg.get('verdict_reason'),
        } for reg in registry if reg.get('reg_key_name')]))

        urls = data.get('urls', [])
        command_results_list.append(generate_results('URL', [{
            'AnalysisID': url.get('analysis_ids'),
            'Categories': url.get('categories'),
            'ContentTypes': url.get('content_types'),
            'Countries': url.get('countries'),
            'CountryCodes': url.get('country_codes'),
            'ID': 0,  # deprecated
            'IPAddresses': url.get('ip_addresses'),
            'Methods': url.get('methods'),
            'Operation': None,  # deprecated
            'OriginalURLs': url.get('original_urls'),
            'ParentFiles': url.get('parent_files'),
            'ParentProcesses': url.get('parent_processes'),
            'ParentProcessesNames': url.get('parent_processes_names'),
            'Referrers': url.get('referrers'),
            'Source': url.get('sources'),
            'Type': url.get('type'),
            'URL': url.get('url'),
            'UserAgents': url.get('user_agents'),
            'Verdict': VERDICT_DICT.get(url.get('verdict')),
            'VerdictReason': url.get('verdict_reason'),
        } for url in urls if url.get('url')]))

        return_results(command_results_list)


    def get_summary(analysis_id):
        """

        Args:
            analysis_id (str):

        Returns:
            str: response
        """
        suffix = 'analysis/{}/archive/logs/summary_v2.json'.format(analysis_id)
        response = http_request('GET', suffix, get_raw=True)
        return response


    def get_summary_command():
        analysis_id = demisto.args().get('analysis_id')
        check_id(analysis_id)
        summary_data = get_summary(analysis_id)

        file_entry = fileResult(
            filename='summary_v2.json',
            data=summary_data,
            file_type=EntryType.ENTRY_INFO_FILE
        )
        return_results(file_entry)


    def main():
        try:
            command = demisto.command()
            if command == 'test-module':
                # This is the call made when pressing the integration test button.
                test_module()
            elif command in ('upload_sample', 'vmray-upload-sample', 'file'):
                upload_sample_command()
            elif command == 'vmray-upload-url':
                upload_url_command()
            elif command == 'vmray-get-submission':
                get_submission_command()
            elif command in ('get_results', 'vmray-get-analysis-by-sample'):
                get_analysis_command()
            elif command == 'vmray-get-sample':
                get_sample_command()
            elif command == 'vmray-get-sample-by-hash':
                get_sample_by_hash_command()
            elif command in (
                    'vmray-get-job-by-sample',
                    'get_job_sample',
                    'vmray-get-job-by-id',
            ):
                get_job_command()
            elif command == 'vmray-get-threat-indicators':
                get_threat_indicators_command()
            elif command == 'vmray-add-tag':
                post_tags()
            elif command == 'vmray-delete-tag':
                delete_tags()
            elif command == 'vmray-get-iocs':
                get_iocs_command()
            elif command == 'vmray-get-summary':
                get_summary_command()
        except Exception as exc:
            return_error(str(exc))


    if __name__ in ('__builtin__', 'builtins', '__main__'):
        main()

    register_module_line('vmray', 'end', __line__())
  subtype: python3
  type: python
system: true
