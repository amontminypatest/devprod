category: Data Enrichment & Threat Intelligence
commonfields:
  id: Cisco Secure Malware Analytics
  version: -1
configuration:
- display: API Key (Leave empty. Fill in the API Key in the password field.)
  displaypassword: API Key
  hiddenusername: true
  name: api_key
  required: false
  type: 9
- display: Feed Name
  name: feed_name
  options:
  - all
  - autorun-registry
  - banking-dns
  - dga-dns
  - dll-hijacking-dns
  - doc-net-com-dns
  - downloaded-pe-dns
  - dynamic-dns
  - irc-dns
  - modified-hosts-dns
  - parked-dns
  - public-ip-check-dns
  - ransomware-dns
  - rat-dns
  - scheduled-tasks
  - sinkholed-ip-dns
  - stolen-cert-dns
  required: true
  type: 16
- additionalinfo: The date or number of days from when to start fetching indicators.
  display: First fetch
  name: first_fetch
  required: false
  type: 0
- defaultvalue: "true"
  display: Fetch indicators
  name: feed
  required: false
  type: 8
- additionalinfo: Indicators from this integration instance will be marked with this
    reputation.
  defaultvalue: Good
  display: Indicator Reputation
  name: feedReputation
  options:
  - None
  - Good
  - Suspicious
  - Bad
  required: false
  type: 18
- additionalinfo: The Traffic Light Protocol (TLP) designation to apply to indicators
    fetched from the feed.
  defaultvalue: GREEN
  display: Traffic Light Protocol Color
  name: tlp_color
  options:
  - RED
  - AMBER
  - GREEN
  - WHITE
  required: false
  type: 15
- additionalinfo: Supports CSV values.
  display: Tags
  name: feedTags
  required: false
  type: 0
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: A - Completely reliable
  display: Source Reliability
  name: feedReliability
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- display: ""
  name: feedExpirationPolicy
  options:
  - never
  - interval
  - indicatorType
  - suddenDeath
  required: false
  type: 17
- display: ""
  name: feedExpirationInterval
  required: false
  type: 1
- defaultvalue: "240"
  display: Feed Fetch Interval
  name: feedFetchInterval
  required: false
  type: 19
- additionalinfo: When selected, the exclusion list is ignored for indicators from
    this feed. This means that if an indicator from this feed is on the exclusion
    list, the indicator might still be added to the system.
  display: Bypass exclusion list
  name: feedBypassExclusionList
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: "true"
  display: Create Relationships
  name: create_relationships
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.5.0
    itemVersion: 1.2.19
    packID: ThreatGrid
    packName: Cisco Secure Malware Analytics
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Secure Malware Analytics (formerly Threat Grid) combines advanced sandboxing
  with threat intelligence into one unified solution to protect organizations from
  malware.
detaileddescription: |-
  **NOTE**: There is no need to enter a value in the **API Key** field. It can be left blank. (Visible only on 6.0.2 and lower versions).


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/cisco-secure-malware-analytics)
display: Cisco Secure Malware Analytics Feed
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEkAAAAyCAYAAAAQlvbeAAAGx0lEQVR42u1Za2xURRTeOzPbYikPeWgRWx7y8JXwQ/3HDw2JxldMBDXGBIhiFF+AihDFhJDwA8KjElhLd/c+lkIRQhtRjPKIKIokCshD9s7c3S0FSgVFnilQlPW77ez2lr3VLs0uNt6TnGxzz8ycc78558w3tz5PPPHEE0888cQTTzz5T4lini5jYb6IBPaPy4c/svz4WKYfWqys/mNYtwGJ1tRNZypPUt38nFRxJdf+WDCxnmlmkhqHZ3cbkFgoGmEaT0KPMNUsyKkvwyRMN0WrP3N99wFJM8MSpDhTo7kFSecEfn6R/tZ4IHU3kJSTF4uZJl6hmrgvG5AUPT6QRaJTybLfR2bVnCPx4SitqUr5uZJsQKJqbAyLiFd9FaJP/pvzuvgc9Bs7sDqqix6dBQnAaraNquL7rPxFxJbWwyBe3VmQaFXMz3TBW2xBMT//JRU2y2VgJxB8n86DxDdK28Gs/Kn8R9mcv+o0SCrviWdHbZtf4ytzWPOiyL3v8MUysEa8QO8sQKqVtn3u68aKO/C3S877otMgabwIz+olSAF3+mAWdY2kaYeegoMGqlobSDDuzzVIROfT7MwkRnRmzkHad4rSDXVrWMg8Tqri47uSRZp0ftFviJJcg0Q1sd22Uc36IdcgsUqzH1rGOTlP78JRzivlImcKInkASRWbZVPfnnOQNN4P+pucF+wC3Td1uUhTgSEGXWNbJm2nsCPZgLRJNuBoZibx1kwK8Z0uIO2xbSiPrVk0bhukxhaQVB5yAemsbUPFXH8m0W3HJiNLLlJd7FAisUKnjXzZ+BzAuUxXWZuU2nraWZBomM9kutlMVyYqM/yFjsxj4egVUlu/IMMWjn4Ef1fop/UfdhYkpcok1OA1eN5MDGtyO9ta4YdtK2yX6MfRKV3jQ4Y1mEbMm9zvaKKUVNcVuJDJVC9L4KUz7dW8jCw9QdyzN1rmSl6D+xVaaWbYALgN0iHpb23GYbDGAhhWqTtB5YXYtNt9+RbZgCta05gnsFsst5fpuMJUgUwy0csso/t8Tyo/PZyFogHyTeOj+fBHIsfHoa8ElKW7R/k88cST/7XQtYlCNOk7QBVGM8O6uf2lNKrYXAXaE3a/+5dFPhDz74IOw0lT9M+XXDGAaeJOrDWE6ryg43Exmx+NxPgRYO89bhg4RKvrhWa5iBnCZrR/Qq9CT0Ofd1CBUnkLP+nX+evtj/QDJZi/ATZ5NcB8jFUCP5W5nJYPws82x9hmALXbt1IUt4uppqE/C/EVsDdA/5JxHcXYxcRI9M7v6bWsaQBTrT0AwQ74Wp3hAGmYDDQJkGal56+wCA2LzY45l6EXoEkltHd0uxff1jCJhfnVDD8gub6KeN/0mocvDGZVsShT3WICPdCtvT7twoD8lZgki5LSJ1hEvI/fl1AKS/FsggOkoTajlSDNbCsxMVTudJIaYiPIXn/7mgBONUZZuCOdHUq4bjiuP02Ol11HVfNlAPQmSrgSmZQGiYVFbRogne/F70yMm50mmlDMieSnzEL8Njhskrt5hKjWIPeRHYMEBl8GptySYQDsAPrGw3RVLIPV09XxeekX1OILOy59MSoFOjZrD10dK3LY+lKNR+U6l4gaL805SHD0UDrwsFjig2QFkhQarF/NdEdp6LyRRsSsa75+bkyVI0Ac2pEfZNf4tmwTUzLt/N10zFXWI7kHaV18XNqhYS24XpCUJacLmWHOha3e0WeSxDj8hmNDPktlAPpShxlAdfOZdEy6mOTydWF62l6dyP0tgFYfHtLSaFUbpFiMVB/rkz1IzheI+QH2E/JkRPnxXY4MWJgCj0ZiczqMqfLg3ehHV5GNSYD5HQ1y0lZuvDD1mQXaTLTYsPw07gCvcZweaJJiMvQx/D0Lp8jj/wYSCe4rpmHzAezwLZhXzHTrXvSSRll236bHreT3sJB5JU0RjNhyNPonMW8C+th8X6h1g8iGOoWtsbY4Trav4fsFgD8R6+1s62uiJn8UYMeZUpxocTh2pwDtQWqWIL2Xeu7XrFFy7AXoqfRcvCSJ1L/Yrilv+nUGelPShQI0+SqsNgpQe34EaMkxaXfTuBL4uTS/TLs6VoLgNTg/4wjkCnSyA6Qh0n4RIM1oA0nY/On8NS/RQMOJd9x7jvU01tqbOsGkWuBJvdoBqteVoT99kuJcUs9CI0S3Snw3QgDSrfZ/cZnewnIrqc4/AIca4biW9EZfmQZ9G/b7HeD1sjMOWg4NQZeghJ4l4Xp/x9wsOhbj5kKDyKJyGrEm+gIxlkEHDA6gxFsYVwENUFW8hrgG+TzxxBNPPPHEE0888eRGyN8R98jGg6pa+wAAAABJRU5ErkJggg==
name: Cisco Secure Malware Analytics
script:
  commands:
  - arguments:
    - description: The maximum number of indicators to retrieve.
      name: limit
    description: Retrieves indicators.
    name: cisco-sma-get-indicators
    outputs:
    - contextPath: CiscoSMA.value
      description: The indicator value.
      type: String
    - contextPath: CiscoSMA.type
      description: The indicator type.
      type: Unknown
    - contextPath: CiscoSMA.Tags
      description: Tags that are associated with the indicator.
      type: String
    - contextPath: CiscoSMA.Description
      description: The feed description.
      type: String
    - contextPath: CiscoSMA.FeedRelatedIndicators.type
      description: The type of the indicators that are associated with the domain.
      type: String
    - contextPath: CiscoSMA.FeedRelatedIndicators.value
      description: Indicators that are associated with the domain.
      type: String
  - arguments: []
    description: 'WARNING: This command will reset your fetch history.'
    name: cisco-sma-reset-fetch-indicators
  dockerimage: demisto/python3:3.10.5.31797
  feed: true
  runonce: false
  script: |
    register_module_line('Cisco Secure Malware Analytics', 'start', __line__())
    from typing import List, Dict, Tuple



    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    FEED_NAME = ['dga-dns', 'autorun-registry', 'banking-dns', 'dll-hijacking-dns', 'doc-net-com-dns',
                 'downloaded-pe-dns', 'dynamic-dns', 'irc-dns', 'modified-hosts-dns', 'parked-dns',
                 'public-ip-check-dns', 'ransomware-dns', 'rat-dns', 'scheduled-tasks', 'sinkholed-ip-dns',
                 'stolen-cert-dns']


    class Client(BaseClient):

        def __init__(self, api_key, verify, first_fetch, feed_name, feed_tags, tlp_color, create_relationships):
            """Implements class for the feed.

            Args:
                api_key: API Key.
                verify: boolean, if *false* feed HTTPS server certificate is verified. Default: *false*
                first_fetch: The date from which to start fetching feeds
                feed_name: The feed names to fetch
                feed_tags: feed tags.
                tlp_color: Traffic Light Protocol color.
                create_relationships: boolean, if *false* no relationships are created. Default: *true*
            """
            super().__init__(base_url="https://panacea.threatgrid.com/api/v3/feeds/", verify=verify)
            self.first_fetch = first_fetch
            self.feed_name = feed_name
            self.feed_tags = feed_tags
            self.tlp_color = tlp_color
            self.create_relationships = create_relationships
            self._api_key = api_key
            self._proxies = handle_proxy()

        def get_indicators(self, feed_name: str, time_stamp: Optional[str]):
            """Retrieves all indicators from the feed.

            Args:
                :param feed_name: the feed name to fetch
                :param time_stamp: Optional - fetch feeds only from this day

            """
            suffix = f'{feed_name}_{time_stamp}.json' if time_stamp else f'{feed_name}.json'
            try:
                return self._http_request('GET', suffix, params={"api_key": self._api_key}, timeout=70)
            except Exception as error:
                if 'Unauthorized' in str(error):
                    raise DemistoException('Authorization Error: make sure the API Key is correctly set')
                else:
                    raise DemistoException(error)


    def create_related_ips(obj: dict, feed_name: str, tlp_color: str) -> List[Dict]:
        """creates list indicators of the related ips.

        Args:
            :param obj: from the response
            :param feed_name: the feed That it was fetch there
            :param tlp_color: Traffic Light Protocol color
            :return: indicators list

        """
        return [({
            "value": ip,
            "type": 'IP',
            "rawJSON": obj,
            "fields": {
                "Tags": [feed_name],
                "reportedby": 'CiscoSMA',
                "Description": obj.get('description'),
                "FirstSeenBySource": obj.get('timestamp'),
                "trafficlightprotocol": tlp_color
            }
        }) for ip in obj.get('ips')]  # type:ignore


    def create_related_files(obj: dict, feed_name: str, tlp_color: str) -> dict:
        """creates dict of the related file indicator.

        Args:
            :param obj: from the response
            :param feed_name: the feed That it was fetch there
            :param tlp_color: Traffic Light Protocol color
            :return: indicator

        """
        return ({
            "value": obj.get('sample_sha256'),
            "type": 'File',
            "rawJSON": obj,
            "fields": {
                "Tags": [feed_name],
                "reportedby": 'CiscoSMA',
                "Description": obj.get('description'),
                "FirstSeenBySource": obj.get('timestamp'),
                "MD5": obj.get('sample_md5'),
                "SHA1": obj.get('sample_sha1'),
                "trafficlightprotocol": tlp_color
            }
        })


    def create_entity_relationships(feed_related_indicators: list, current_domain: str) -> list:
        """

        Args:
            feed_related_indicators: Indicators related to the domain returned from fetch_indicators.
            current_domain: Returned indicator from fetch_indicators.

        Returns:
            relationships: EntityRelationships list.

        """
        relationships = []
        for relation in feed_related_indicators:
            if relation.get('value') != '':
                entity_relation = EntityRelationship(
                    name=EntityRelationship.Relationships.RELATED_TO,
                    entity_a=current_domain,
                    entity_a_type='Domain',
                    entity_b=relation.get('value'),
                    entity_b_type=relation.get('type')
                )
                relationships.append(entity_relation.to_indicator())
        return relationships


    def test_module(client: Client) -> str:
        """Goes through all the code of the fetch.
        Args:
            client: Client object with request

        Returns:
            str: ok.
        """
        fetch_indicators(client)
        return 'ok'


    def fetch_indicators(client: Client, time_to_stop_fetch: Optional[datetime] = None) -> Tuple[List, bool]:
        """Retrieves indicators from the feed

        Args:
            client: Client object with request
            time_to_stop_fetch: Time to stop the fetch before it falls on timeout

        Returns:
            List. Processed indicator from feed.
        """
        fetch_time_stamp = None
        files = ['sample_sha256', 'sample_sha1', 'sample_md5']
        if client.first_fetch.date() < arg_to_datetime('now').date():  # type:ignore
            fetch_time_stamp = client.first_fetch.date().isoformat()
        else:
            client.first_fetch = arg_to_datetime('now')

        indicators = []
        domains_map: Dict[str, dict] = {}
        for name in client.feed_name:
            if time_to_stop_fetch and arg_to_datetime('now') > time_to_stop_fetch:  # type:ignore
                return [], False
            result = client.get_indicators(feed_name=name, time_stamp=fetch_time_stamp)
            for obj in result:
                feed_related_indicators = [{'type': 'IP', 'value': ip} for ip in obj.get('ips')]
                feed_related_indicators.extend([{'type': 'File', 'value': obj.get(file_hash)} for file_hash in files])
                current_domain = obj.get('domain')
                relationships = create_entity_relationships(feed_related_indicators, current_domain)
                if current_domain in domains_map:
                    if name not in domains_map[current_domain]['fields']['Tags']:
                        domains_map[current_domain]['fields']['Tags'].append(name)
                    domains_map[current_domain]['fields']['FeedRelatedIndicators'].extend(
                        related for related in feed_related_indicators
                        if related not in domains_map[current_domain]['fields']['FeedRelatedIndicators'])
                    existing_relations = [relation.get('entityB') for
                                          relation in domains_map[current_domain]['relationships']]
                    new_relations = filter(lambda relation: relation.get('entityB') not in existing_relations, relationships)
                    domains_map[current_domain]['relationships'].extend(new_relations)

                else:
                    domains_map[current_domain] = {
                        "value": current_domain,
                        "type": 'Domain',
                        "rawJSON": obj,
                        "relationships": relationships,
                        "fields": {
                            "Tags": [name],
                            "reportedby": 'CiscoSMA',
                            "FeedRelatedIndicators": feed_related_indicators,
                            "Description": obj.get('description'),
                            "FirstSeenBySource": obj.get('timestamp')
                        }
                    }
                if client.tlp_color:
                    domains_map[current_domain]['fields']['trafficlightprotocol'] = client.tlp_color
                if client.feed_tags:
                    domains_map[current_domain]['fields']['Tags'] += client.feed_tags
                indicators += create_related_ips(obj, name, client.tlp_color)
                indicators.append(create_related_files(obj, name, client.tlp_color))

        indicators += list(domains_map.values())
        return indicators, True


    def fetch_indicators_command(client: Client, time_to_stop_fetch: datetime = None):
        """Retrieves indicators from the feed

        Args:
            client: Client object with request
            time_to_stop_fetch: Time to stop the fetch before it falls on the docker timeout

        Returns:
            List. Processed indicator from feed.
        """
        current_date = arg_to_datetime('now').date()  # type:ignore
        while client.first_fetch.date() <= current_date:
            indicators, status = fetch_indicators(client, time_to_stop_fetch)
            if not status:
                return
            for iter_ in batch(indicators, batch_size=2000):
                demisto.createIndicators(iter_)
            # Each request returns one day's indicators, so we'll keep the date of the next day in IntegrationContext.
            next_fetch = (dateparser.parse('tomorrow', settings={'RELATIVE_BASE': client.first_fetch}))  # type:ignore
            if client.first_fetch.date() < current_date:
                demisto.setIntegrationContext({'last_fetch': next_fetch.isoformat()})  # type:ignore
            client.first_fetch = next_fetch
            demisto.debug(f'{len(indicators)} XSOAR Indicators were created.')
        return


    def get_indicators_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """Wrapper for retrieving indicators from the feed to the war-room.

        Args:
            client: Client object with request
            args: demisto.args()

        Returns:
            Demisto Outputs.
        """
        limit = int(args.get('limit', 50))
        indicators, status = fetch_indicators(client)

        limit_indicators = indicators[:limit]

        readable_output = tableToMarkdown('CiscoSMA Indicators:', t=limit_indicators, headers=['value', 'type'])
        command_results = CommandResults(
            outputs_prefix='CiscoSMA',
            outputs_key_field='value',
            outputs=limit_indicators,
            readable_output=readable_output,
            raw_response=indicators
        )
        return command_results


    def reset_last_run():
        """
        Reset the last run from the integration context
        """
        demisto.setIntegrationContext({})
        return CommandResults(readable_output='Fetch history deleted successfully')


    def main():
        """
        PARSE AND VALIDATE FEED PARAMS
        """
        try:
            time_to_stop_fetch = arg_to_datetime(arg='in 25 minutes')  # type:ignore # To stop before docker timeout.
            params = demisto.params()
            args = demisto.args()
            api_key = params.get('api_key').get('password')
            if not api_key:
                raise DemistoException('API Key was not given. Please insert your API Key.')
            verify = not params.get('insecure', False)
            feed_name = params.get('feed_name')
            if 'all' in feed_name:
                feed_name = FEED_NAME
            feed_tags = argToList(params.get('feedTags'))
            tlp_color = params.get('tlp_color')
            create_relationships = params.get('create_relationships', True)
            if fetch_date_string := demisto.getIntegrationContext().get('last_fetch'):
                first_fetch = arg_to_datetime(fetch_date_string)  # type:ignore
            else:
                if not (first_fetch_param := params.get('first_fetch')):
                    first_fetch_param = 'today'
                first_fetch = arg_to_datetime(arg=first_fetch_param, arg_name='First fetch')  # type:ignore
            command = demisto.command()
            demisto.debug(f'Command being called is: {command}')

            client = Client(api_key=api_key, verify=verify, feed_name=feed_name, first_fetch=first_fetch,
                            feed_tags=feed_tags, tlp_color=tlp_color, create_relationships=create_relationships)

            if command == 'test-module':
                return_results(test_module(client))

            elif command == 'fetch-indicators':
                fetch_indicators_command(client, time_to_stop_fetch)

            elif command == 'cisco-sma-get-indicators':
                return_results(get_indicators_command(client, args))

            elif command == "cisco-sma-reset-fetch-indicators":
                return_results(reset_last_run())

            else:
                raise NotImplementedError(f'Command "{command}" is not implemented.')

        except Exception as err:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(err)}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Cisco Secure Malware Analytics', 'end', __line__())
  subtype: python3
  type: python
system: true
