category: Messaging
commonfields:
  id: Microsoft Teams Management
  version: -1
configuration:
- defaultvalue: 3307a0ab-612c-47af-b3b5-8208247562db
  display: Application ID
  name: app_id
  required: true
  section: Connect
  type: 0
- additionalinfo: Azure AD endpoint associated with a national cloud.
  advanced: true
  defaultvalue: https://login.microsoftonline.com
  display: Azure AD endpoint
  name: azure_ad_endpoint
  options:
  - https://login.microsoftonline.com
  - https://login.microsoftonline.us
  - https://login.microsoftonline.de
  - https://login.chinacloudapi.cn
  required: false
  section: Connect
  type: 15
- advanced: true
  defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- additionalinfo: Type of authentication - could be Client Credentials Authorization
    Flow (recommended) or Device Flow
  advanced: true
  defaultvalue: Device Code
  display: Authentication Type
  name: authentication_type
  options:
  - Device Code
  - Client Credentials
  required: false
  section: Connect
  type: 15
- advanced: true
  display: Tenant ID (for Client Credentials mode)
  name: tenant_id
  required: false
  section: Connect
  type: 0
- display: Client Secret (for Client Credentials mode)
  displaypassword: Client Secret (for Client Credentials mode)
  hiddenusername: true
  name: credentials
  required: false
  section: Connect
  type: 9
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.2.11
    packID: MicrosoftTeams
    packName: Microsoft Teams
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Manage teams and members in Microsoft Teams.
detaileddescription: "## Authorization\nIn both options below, the [device authorization
  grant flow](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)
  is used.\n##### There are two ways to authenticate to the Microsoft Graph Services:\n1.
  *Client Credentials Flow* (Recommended).\n2. *Device Code Flow*.\n\n\n### Client
  Credentials Flow (Recommended)\n___\nFollow these steps for a self-deployed configuration:\n\n1.
  To use a self-configured Azure application, you need to add a new Azure App Registration
  in the Azure Portal. To add the registration, refer to the following [Microsoft
  article](https://docs.microsoft.com/en-us/microsoft-365/security/defender/api-create-app-web?view=o365-worldwide#create-an-app)
  steps 1-8.\n2. In the instance configuration, under the ***Authentication Type***
  field select the ***Client Credentials*** option.\n3. Enter your Client/Application
  ID in the ***Application ID*** parameter. \n4. Enter your Client Secret in the ***Password***
  parameter.\n5. Enter your Tenant ID in the ***Tenant ID*** parameter.\n6. Run the
  ***!msgraph-apps-auth-test*** command to test the connection and the authorization
  process.\n\n\n### Device Code Flow\n___\n\nUse the [device code flow](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)\nto
  link Microsoft Graph Services with Cortex XSOAR.\n\nIn order to connect to Microsoft
  Graph Services using either Cortex XSOAR Azure App or the Self-Deployed Azure App:\n1.
  Fill in the required parameters.\n2. Run the ***!msgraph-apps-auth-start*** command.\n3.
  Follow the instructions that appear.\n4. Run the ***!msgraph-apps-auth-complete***
  command.\n1. In the instance configuration, under the ***Authentication Type***
  field select the ***Device*** option.\n2. Fill in the required parameters.\n3. Run
  the ***!msgraph-apps-auth-start*** command.\n4. Follow the instructions that appear.\n5.
  Run the ***!msgraph-apps-auth-complete*** command.\n\nAt the end of the process
  you'll see a message that you've logged in successfully.\n\n#### Cortex XSOAR Azure
  App\n\nIn order to use the Cortex XSOAR Azure application, use the default application
  ID (3307a0ab-612c-47af-b3b5-8208247562db).\n\n#### Self-Deployed Azure App\n\nTo
  use a self-configured Azure application, you need to add a new Azure App Registration
  in the Azure Portal, with mobile and desktop flows enabled.\n\n----\n\nRequired
  Permissions\n* Group.ReadWrite.All - Application\n* Team.ReadBasic.All - Application\n*
  TeamMember.ReadWrite.All - Application\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/microsoft-teams-management)"
display: Microsoft Teams Management
image: data:image/png;base64,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
name: Microsoft Teams Management
script:
  commands:
  - arguments: []
    description: Run this command to start the authorization process and follow the
      instructions in the command results.
    name: microsoft-teams-auth-start
  - arguments: []
    description: |-
      Run this command to complete the authorization process.
      Should be used after running the microsoft-teams-auth-start command.
    name: microsoft-teams-auth-complete
  - arguments: []
    description: Run this command if for some reason you need to rerun the authentication
      process.
    name: microsoft-teams-auth-reset
  - arguments: []
    description: Tests connectivity to Microsoft.
    name: microsoft-teams-auth-test
  - arguments:
    - description: The name of the team.
      name: display_name
      required: true
    - description: Description of the team.
      name: description
    - auto: PREDEFINED
      defaultValue: public
      description: 'The visibility of the group and team. Possible values are: "public"
        and "private".'
      name: visibility
      predefined:
      - public
      - private
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether guests can add and update channels. Possible values are:
        "true" and "false".'
      name: allow_guests_create_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether guests can delete channels. Possible values are: "true"
        and "false".'
      name: allow_guests_delete_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add and update private channels. Possible
        values are: "true" and "false".'
      name: allow_members_create_private_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add and update channels. Possible values are:
        "true" and "false".'
      name: allow_members_create_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can delete channels. Possible values are: "true"
        and "false".'
      name: allow_members_delete_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add and remove apps. Possible values are:
        "true" and "false".'
      name: allow_members_add_remove_apps
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add, update, and remove tabs. Possible values
        are: "true" and "false".'
      name: allow_members_add_remove_tabs
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add, update, and remove connectors. Possible
        values are: "true" and "false".'
      name: allow_members_add_remove_connectors
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether users can edit their messages. Possible values are: "true"
        and "false".'
      name: allow_user_edit_messages
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether users can delete their messages. Possible values are:
        "true" and "false".'
      name: allow_user_delete_messages
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether owners can delete any message. Possible values are: "true"
        and "false".'
      name: allow_owner_delete_messages
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether @team mentions are allowed. Possible values are: "true"
        and "false".'
      name: allow_team_mentions
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether @channel mentions are allowed. Possible values are: "true"
        and "false".'
      name: allow_channel_mentions
      predefined:
      - "false"
      - "true"
    - description: ID of the user to be the team owner (e.g., 0040b377-61d8-43db-94f5-81374122dc7e).
        Can be retrieved by running the msgraph-user-list command.
      name: owner
      required: true
    description: Creates a new team.
    name: microsoft-teams-team-create
  - arguments:
    - description: ID of group to create team from. Can be retrieved by running the
        msgraph-groups-list-groups command.
      name: group_id
      required: true
    - description: The name of the team.
      name: display_name
    - description: Description of the team.
      name: description
    - auto: PREDEFINED
      defaultValue: public
      description: 'The visibility of the group and team. Possible values are: "public"
        and "private".'
      name: visibility
      predefined:
      - public
      - private
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether guests can add and update channels. Possible values are:
        "true" and "false".'
      name: allow_guests_create_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether guests can delete channels. Possible values are: "true"
        and "false".'
      name: allow_guests_delete_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add and update private channels. Possible
        values are: "true" and "false".'
      name: allow_members_create_private_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add and update channels. Possible values are:
        "true" and "false".'
      name: allow_members_create_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can delete channels. Possible values are: "true"
        and "false".'
      name: allow_members_delete_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add and remove apps. Possible values are:
        "true" and "false".'
      name: allow_members_add_remove_apps
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add, update, and remove tabs. Possible values
        are: "true" and "false".'
      name: allow_members_add_remove_tabs
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether members can add, update, and remove connectors. Possible
        values are: "true" and "false".'
      name: allow_members_add_remove_connectors
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether users can edit their messages. Possible values are: "true"
        and "false".'
      name: allow_user_edit_messages
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether users can delete their messages. Possible values are:
        "true" and "false".'
      name: allow_user_delete_messages
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether owners can delete any message. Possible values are: "true"
        and "false".'
      name: allow_owner_delete_messages
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether @team mentions are allowed. Possible values are: "true"
        and "false".'
      name: allow_team_mentions
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether @channel mentions are allowed. Possible values are: "true"
        and "false".'
      name: allow_channel_mentions
      predefined:
      - "false"
      - "true"
    description: Create a new team under a group. In order to create a team, the group
      must have a least one owner and the group cannot be of type Security.
    name: microsoft-teams-team-create-from-group
  - arguments: []
    description: Returns all the groups that have teams in an organization.
    name: microsoft-teams-teams-list
    outputs:
    - contextPath: MicrosoftTeams.Team.securityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MicrosoftTeams.Team.preferredDataLocation
      description: The preferred data location for the group.
      type: String
    - contextPath: MicrosoftTeams.Team.resourceProvisioningOptions
      description: Specifies the group resources that are provisioned as part of Microsoft
        365 group creation, that are not normally part of default group creation.
        Possible value is Team.
      type: String
    - contextPath: MicrosoftTeams.Team.createdDateTime
      description: 'Timestamp of when the group was created. The value cannot be modified
        and is automatically populated when the group is created. The Timestamp type
        represents date and time information using ISO 8601 format and is always in
        UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: ''2014-01-01T00:00:00Z''.'
      type: String
    - contextPath: MicrosoftTeams.Team.mailNickname
      description: The alias of the group in an Exchange organization.
      type: String
    - contextPath: MicrosoftTeams.Team.securityIdentifier
      description: Security identifier of the group, used in Windows scenarios.
      type: String
    - contextPath: MicrosoftTeams.Team.mailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MicrosoftTeams.Team.displayName
      description: The display name for the group.
      type: String
    - contextPath: MicrosoftTeams.Team.visibility
      description: 'Specifies the visibility of a Microsoft 365 group. Possible values
        are: Private, Public, or Hiddenmembership. Blank values are treated as public.'
      type: String
    - contextPath: MicrosoftTeams.Team.proxyAddresses
      description: 'Email addresses for the group that direct to the same group mailbox.
        For example: ["SMTP: bob@demisto.com", "smtp: bob@sales.demisto.com"]'
      type: String
    - contextPath: MicrosoftTeams.Team.mail
      description: The SMTP address for the group, for example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MicrosoftTeams.Team.id
      description: The unique identifier for the group.
      type: String
    - contextPath: MicrosoftTeams.Team.description
      description: An optional description for the group.
      type: String
  - arguments:
    - description: ID of the team to update. Can be retrieved by running the microsoft-teams-teams-list
        command.
      name: team_id
      required: true
    - description: The name of the team.
      name: display_name
    - description: Description of the team.
      name: description
    - auto: PREDEFINED
      description: 'Whether guests can add and update channels. Possible values are:
        "true" and "false".'
      name: allow_guests_create_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether guests can delete channels. Possible values are: "true"
        and "false".'
      name: allow_guests_delete_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether members can add and update private channels. Possible
        values are: "true" and "false".'
      name: allow_members_create_private_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether members can add and update channels. Possible values are:
        "true" and "false".'
      name: allow_members_create_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether members can delete channels. Possible values are: "true"
        and "false".'
      name: allow_members_delete_channels
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether members can add and remove apps. Possible values are:
        "true" and "false".'
      name: allow_members_add_remove_apps
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether members can add, update, and remove tabs. Possible values
        are: "true" and "false".'
      name: allow_members_add_remove_tabs
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether members can add, update, and remove connectors. Possible
        values are: "true" and "false".'
      name: allow_members_add_remove_connectors
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether users can edit their messages. Possible values are: "true"
        and "false".'
      name: allow_user_edit_messages
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether users can delete their messages. Possible values are:
        "true" and "false".'
      name: allow_user_delete_messages
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether owners can delete any message. Possible values are: "true"
        and "false".'
      name: allow_owner_delete_messages
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether @team mentions are allowed. Possible values are: "true"
        and "false".'
      name: allow_team_mentions
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      description: 'Whether @channel mentions are allowed. Possible values are: "true"
        and "false".'
      name: allow_channel_mentions
      predefined:
      - "false"
      - "true"
    description: Update the properties of the specified team.
    name: microsoft-teams-team-update
  - arguments:
    - description: ID of the team to delete. Can be retrieved by running the microsoft-teams-teams-list
        command.
      name: team_id
      required: true
    description: 'Deletes a group. Note: it might take time for the team to disappear
      from the teams list.'
    name: microsoft-teams-team-delete
  - arguments:
    - description: ID of team to get. Can be retrieved by running the microsoft-teams-teams-list
        command.
      name: team_id
      required: true
    description: Retrieve the properties and relationships of the specified team.
    name: microsoft-teams-team-get
    outputs:
    - contextPath: MicrosoftTeams.Team.createdDateTime
      description: 'Timestamp of when the group was created. The value cannot be modified
        and is automatically populated when the group is created. The Timestamp type
        represents date and time information using ISO 8601 format and is always in
        UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: ''2014-01-01T00:00:00Z''.'
      type: Date
    - contextPath: MicrosoftTeams.Team.classification
      description: Typically describes the data or business sensitivity of the team.
      type: String
    - contextPath: MicrosoftTeams.Team.isArchived
      description: Whether this team is in read-only mode.
      type: Boolean
    - contextPath: MicrosoftTeams.Team.displayName
      description: The display name for the group.
      type: String
    - contextPath: MicrosoftTeams.Team.visibility
      description: 'Specifies the visibility of a Microsoft 365 group. Possible values
        are: Private, Public, or Hiddenmembership; blank values are treated as public.'
      type: String
    - contextPath: MicrosoftTeams.Team.id
      description: The unique identifier for the group.
      type: String
    - contextPath: MicrosoftTeams.Team.description
      description: An optional description for the group.
      type: String
  - arguments:
    - description: ID of the team to get the member of. Can be retrieved by running
        the microsoft-teams-teams-list command.
      name: team_id
      required: true
    description: Returns the members of the specified team.
    name: microsoft-teams-members-list
    outputs:
    - contextPath: MicrosoftTeams.TeamMember.teamId
      description: The unique identifier for the group.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.displayName
      description: The display name of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.email
      description: The email of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.id
      description: Unique ID of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.roles
      description: The roles for that user.
      type: String
  - arguments:
    - description: ID of member to get. Can be retrieved by running the microsoft-teams-members-list
        command.
      name: membership_id
      required: true
    - description: ID of the team to get the member of. Can be retrieved by running
        the microsoft-teams-teams-list command.
      name: team_id
      required: true
    description: Gets a member of a team.
    name: microsoft-teams-member-get
    outputs:
    - contextPath: MicrosoftTeams.TeamMember.teamId
      description: The unique identifier for the group.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.displayName
      description: The display name of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.email
      description: The email of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.id
      description: Unique ID of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.roles
      description: The roles for that user.
      type: String
  - arguments:
    - description: ID of the team to add the user to. Can be retrieved by running
        the microsoft-teams-teams-list command.
      name: team_id
      required: true
    - description: Email address or ID of the user to add to the team. The ID can
        be retrieved by running the microsoft-teams-members-list command.
      name: user_id
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether to add the member with the owner role. Possible values
        are: "false" and "true".'
      name: is_owner
      predefined:
      - "false"
      - "true"
    description: Add a user to be a team member.
    name: microsoft-teams-member-add
    outputs:
    - contextPath: MicrosoftTeams.TeamMember.displayName
      description: The display name of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.email
      description: The email of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.id
      description: Unique ID of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.roles
      description: The roles for that user.
      type: String
  - arguments:
    - description: ID of the team to remove the user from. Can be retrieved by running
        the microsoft-teams-teams-list command.
      name: team_id
      required: true
    - description: ID of the member to remove from the team. Can be retrieved by running
        the microsoft-teams-members-list command.
      name: membership_id
      required: true
    description: Remove a member from the team.
    name: microsoft-teams-member-remove
  - arguments:
    - description: ID of the team to update the member in. Can be retrieved by running
        the microsoft-teams-teams-list command.
      name: team_id
      required: true
    - description: ID of the team member to update. Can be retrieved by running the
        microsoft-teams-members-list command.
      name: membership_id
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether to set the member with the owner role. Possible values
        are: "false" and "true".'
      name: is_owner
      predefined:
      - "false"
      - "true"
    description: Updates a team member.
    name: microsoft-teams-member-update
    outputs:
    - contextPath: MicrosoftTeams.TeamMember.displayName
      description: The display name of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.email
      description: The email of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.id
      description: Unique ID of the user.
      type: String
    - contextPath: MicrosoftTeams.TeamMember.roles
      description: The roles for that user.
      type: String
  - arguments:
    - description: ID of the team to archive. Can be retrieved by running the microsoft-teams-teams-list
        command.
      name: team_id
      required: true
    description: Archive the specified team. When a team is archived, users can no
      longer send or like messages on any channel in the team, edit the team's name,
      description, or other settings, or in general make most changes to the team.
      Membership changes to the team continue to be allowed. Archiving is an async
      operation. A team is archived once the async operation completes successfully,
      which may occur subsequent to a response from this command. In order to archive
      a team, the team and group must have an owner.
    name: microsoft-teams-team-archive
  - arguments:
    - description: ID of the team to unarchive. Can be retrieved by running the microsoft-teams-teams-list
        command.
      name: team_id
      required: true
    description: Restore an archived team. This restores the users' ability to send
      messages and edit the team, abiding by tenant and team settings. Unarchiving
      is an async operation. A team is unarchived once the async operation completes
      successfully, which may occur subsequent to a response from this command.
    name: microsoft-teams-team-unarchive
  - arguments:
    - description: ID of the team to clone. Can be retrieved by running the microsoft-teams-teams-list
        command.
      name: team_id
      required: true
    - description: The name of the team.
      name: display_name
      required: true
    - description: Description of the team.
      name: description
    - auto: PREDEFINED
      defaultValue: public
      description: 'The visibility of the group and team. Possible values are: "public"
        and "private".'
      name: visibility
      predefined:
      - public
      - private
    - auto: PREDEFINED
      defaultValue: "true"
      description: 'Whether to copy Microsoft Teams apps that are installed in the
        team. Possible values are: "false" and "true".'
      name: clone_apps
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "true"
      description: 'Whether to copy the tabs within channels. Possible values are:
        "false" and "true".'
      name: clone_tabs
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "true"
      description: 'Whether to copy all settings within the team, along with key group
        settings. Possible values are: "false" and "true".'
      name: clone_settings
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "true"
      description: 'Whether to copy the channel structure (but not the messages in
        the channel). Possible values are: "false" and "true".'
      name: clone_channels
      predefined:
      - "false"
      - "true"
    description: Create a copy of a team. This operation also creates a copy of the
      corresponding group. Cloning is a long-running operation.
    name: microsoft-teams-team-clone
  - arguments:
    - description: ID of the user (e.g., 2827c1e7-edb6-4529-b50d-25984e968637). Can
        be retrieved by running the msgraph-user-list command.
      name: user_id
      required: true
    description: Get the teams in Microsoft Teams that the user is a direct member
      of.
    name: microsoft-teams-teams-list-joined
    outputs:
    - contextPath: MicrosoftTeams.Team.createdDateTime
      description: 'Timestamp of when the group was created. The value cannot be modified
        and is automatically populated when the group is created. The Timestamp type
        represents date and time information using ISO 8601 format and is always in
        UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: ''2014-01-01T00:00:00Z''.'
      type: Date
    - contextPath: MicrosoftTeams.Team.classification
      description: Typically describes the data or business sensitivity of the team.
      type: String
    - contextPath: MicrosoftTeams.Team.isArchived
      description: Whether this team is in read-only mode.
      type: Boolean
    - contextPath: MicrosoftTeams.Team.displayName
      description: The display name for the group.
      type: String
    - contextPath: MicrosoftTeams.Team.visibility
      description: 'Specifies the visibility of a Microsoft 365 group. Possible values
        are: Private, Public, or Hiddenmembership; blank values are treated as public.'
      type: String
    - contextPath: MicrosoftTeams.Team.id
      description: The unique identifier for the group.
      type: String
    - contextPath: MicrosoftTeams.Team.description
      description: An optional description for the group.
      type: String
  dockerimage: demisto/crypto:1.0.0.42817
  runonce: false
  script: |
    register_module_line('Microsoft Teams Management', 'start', __line__())


    ### GENERATED CODE ###: from MicrosoftApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)
    import traceback




    import requests
    import re
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from typing import Dict, Tuple, List, Optional


    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'


    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line
    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'
    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'
    SESSION_STATE = 'session_state'
    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }
    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }
    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }


    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: Optional[str] = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = '{graph_endpoint}/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: Optional[str] = '',
                     multi_resource: bool = False,
                     resources: List[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: Optional[int] = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     endpoint: str = 'com',
                     certificate_thumbprint: Optional[str] = None,
                     retry_on_rate_limit: bool = False,
                     private_key: Optional[str] = None,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
                retry_on_rate_limit: If the http request returns with a 429 - Rate limit reached response,
                                     retry the request using a scheduled command.
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]
            self.endpoint = endpoint
            self.retry_on_rate_limit = retry_on_rate_limit
            if retry_on_rate_limit and (429 not in self._ok_codes):
                self._ok_codes = self._ok_codes + (429,)
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=GRAPH_ENDPOINTS[self.endpoint])
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: Dict[str, str] = {}

        def is_command_executed_from_integration(self):
            ctx = demisto.callingContext.get('context', {})
            executed_commands = ctx.get('ExecutedCommands', [{'moduleBrand': 'Scripts'}])

            if executed_commands:
                return executed_commands[0].get('moduleBrand', "") != 'Scripts'

            return True

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: Optional[str] = None,
                resource: str = '', overwrite_rate_limit_retry=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
                overwrite_rate_limit_retry : Skip rate limit retry
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers.update(headers)

            if self.timeout:
                kwargs['timeout'] = self.timeout

            should_http_retry_on_rate_limit = self.retry_on_rate_limit and not overwrite_rate_limit_retry
            if should_http_retry_on_rate_limit and not kwargs.get('error_handler'):
                kwargs['error_handler'] = self.handle_error_with_metrics

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            if should_http_retry_on_rate_limit and self.is_command_executed_from_integration():
                self.create_api_metrics(response.status_code)
            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            if should_http_retry_on_rate_limit and response.status_code == 429 and is_demisto_version_ge('6.2.0'):
                command_args = demisto.args()
                ran_once_flag = command_args.get('ran_once_flag')
                demisto.info(f'429 MS rate limit for command {demisto.command()}, where ran_once_flag is {ran_once_flag}')
                # We want to retry on rate limit only once
                if ran_once_flag:
                    try:
                        error_message = response.json()
                    except Exception:
                        error_message = 'Rate limit reached on retry - 429 Response'
                    demisto.info(f'Error in retry for MS rate limit - {error_message}')
                    raise DemistoException(error_message)

                else:
                    demisto.info(f'Scheduling command {demisto.command()}')
                    command_args['ran_once_flag'] = True
                    return_results(self.run_retry_on_rate_limit(command_args))
                    sys.exit(0)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self, resource: str = '', scope: Optional[str] = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource (str): The resource identifier for which the generated token will have access to.
                scope (str): A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            if self.multi_resource:
                access_token = integration_context.get(resource)
            else:
                access_token = integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    for resource_str in self.resources:
                        access_token, expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _oproxy_authorize(self, resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: Optional[str] = None,
                                     integration_context: Optional[dict] = None
                                     ) -> Tuple[str, int, str]:
            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                else:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                          resource)
                        self.resource_to_access_token[resource] = access_token

                    return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: Optional[str] = None,
                                                        resource: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope if scope else self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=self.resource if not resource else resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_token_device_code(
                self, refresh_token: str = '', scope: Optional[str] = None, integration_context: Optional[dict] = None
        ) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        def run_retry_on_rate_limit(self, args_for_next_run: dict):
            return CommandResults(readable_output="Rate limit reached, rerunning the command in 1 min",
                                  scheduled_command=ScheduledCommand(command=demisto.command(), next_run_in_seconds=60,
                                                                     args=args_for_next_run))

        def handle_error_with_metrics(self, res):
            self.create_api_metrics(res.status_code)
            self.client_error_handler(res)

        def create_api_metrics(self, status_code):
            execution_metrics = ExecutionMetrics()
            ok_codes = (200, 201, 202, 204, 206)

            if not execution_metrics.is_supported() or demisto.command() in ['test-module', 'fetch-incidents']:
                return
            if status_code == 429:
                execution_metrics.quota_error += 1
            elif status_code in ok_codes:
                execution_metrics.success += 1
            else:
                execution_metrics.general_error += 1
            return_results(execution_metrics.metrics)

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: Optional[str]) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search.group('url') if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})
    and enter the code **{user_code}** to authenticate.
    2. Run the **{complete_command}** command in the War Room."""


    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###



    from typing import Dict, Optional

    import urllib3

    urllib3.disable_warnings()
    GRANT_BY_CONNECTION = {'Device Code': DEVICE_CODE, 'Client Credentials': CLIENT_CREDENTIALS}
    SCOPE_BY_CONNECTION = {'Device Code': 'offline_access Group.ReadWrite.All TeamMember.ReadWrite.All Team.ReadBasic.All',
                           'Client Credentials': 'https://graph.microsoft.com/.default'}


    class Client:
        def __init__(self, app_id: str, verify: bool, proxy: bool,
                     connection_type: str, tenant_id: str, enc_key: str,
                     azure_ad_endpoint: str = 'https://login.microsoftonline.com'):
            if '@' in app_id:
                app_id, refresh_token = app_id.split('@')
                integration_context = get_integration_context()
                integration_context.update(current_refresh_token=refresh_token)
                set_integration_context(integration_context)

            token_retrieval_url = 'https://login.microsoftonline.com/organizations/oauth2/v2.0/token' \
                                  if 'Client' not in connection_type \
                                  else None

            client_args = assign_params(
                self_deployed=True,
                auth_id=app_id,
                token_retrieval_url=token_retrieval_url,
                grant_type=GRANT_BY_CONNECTION[connection_type],
                base_url='https://graph.microsoft.com',
                verify=verify,
                proxy=proxy,
                scope=SCOPE_BY_CONNECTION[connection_type],
                azure_ad_endpoint=azure_ad_endpoint,
                tenant_id=tenant_id,
                enc_key=enc_key
            )
            self.ms_client = MicrosoftClient(**client_args)
            self.connection_type = connection_type

        @logger
        def create_team_request(
                self,
                display_name: str,
                owner: str,
                description: Optional[str] = None,
                visibility: str = 'public',
                allow_guests_create_channels: bool = False,
                allow_guests_delete_channels: bool = False,
                allow_members_create_private_channels: bool = False,
                allow_members_create_channels: bool = False,
                allow_members_delete_channels: bool = False,
                allow_members_add_remove_apps: bool = False,
                allow_members_add_remove_tabs: bool = False,
                allow_members_add_remove_connectors: bool = False,
                allow_user_edit_messages: bool = False,
                allow_user_delete_messages: bool = False,
                allow_owner_delete_messages: bool = False,
                allow_team_mentions: bool = False,
                allow_channel_mentions: bool = False,
        ) -> None:
            self.ms_client.http_request(
                method='POST',
                url_suffix='/v1.0/teams',
                json_data={
                    'template@odata.bind': "https://graph.microsoft.com/v1.0/teamsTemplates('standard')",
                    'displayName': display_name,
                    'description': description,
                    'visibility': visibility,
                    'members': [{
                        '@odata.type': '#microsoft.graph.aadUserConversationMember',
                        'roles': ['owner'],
                        'user@odata.bind': f"https://graph.microsoft.com/v1.0/users('{owner}')",
                    }],
                    'guestSettings': {
                        'allowCreateUpdateChannels': allow_guests_create_channels,
                        'allowDeleteChannels': allow_guests_delete_channels,
                    },
                    'memberSettings': {
                        'allowCreatePrivateChannels': allow_members_create_private_channels,
                        'allowCreateUpdateChannels': allow_members_create_channels,
                        'allowDeleteChannels': allow_members_delete_channels,
                        'allowAddRemoveApps': allow_members_add_remove_apps,
                        'allowCreateUpdateRemoveTabs': allow_members_add_remove_tabs,
                        'allowCreateUpdateRemoveConnectors': allow_members_add_remove_connectors,
                    },
                    'messagingSettings': {
                        'allowUserEditMessages': allow_user_edit_messages,
                        'allowUserDeleteMessages': allow_user_delete_messages,
                        'allowOwnerDeleteMessages': allow_owner_delete_messages,
                        'allowTeamMentions': allow_team_mentions,
                        'allowChannelMentions': allow_channel_mentions,
                    },
                },
                resp_type='response',
            )

        @logger
        def create_team_from_group_request(
                self,
                group_id: str,
                display_name: str,
                description: Optional[str] = None,
                visibility: str = 'public',
                allow_guests_create_channels: bool = False,
                allow_guests_delete_channels: bool = False,
                allow_members_create_private_channels: bool = False,
                allow_members_create_channels: bool = False,
                allow_members_delete_channels: bool = False,
                allow_members_add_remove_apps: bool = False,
                allow_members_add_remove_tabs: bool = False,
                allow_members_add_remove_connectors: bool = False,
                allow_user_edit_messages: bool = False,
                allow_user_delete_messages: bool = False,
                allow_owner_delete_messages: bool = False,
                allow_team_mentions: bool = False,
                allow_channel_mentions: bool = False,
        ) -> None:
            self.ms_client.http_request(
                method='PUT',
                url_suffix=f'/v1.0/groups/{group_id}/team',
                json_data={
                    'displayName': display_name,
                    'description': description,
                    'visibility': visibility,
                    'guestSettings': {
                        'allowCreateUpdateChannels': allow_guests_create_channels,
                        'allowDeleteChannels': allow_guests_delete_channels,
                    },
                    'memberSettings': {
                        'allowCreatePrivateChannels': allow_members_create_private_channels,
                        'allowCreateUpdateChannels': allow_members_create_channels,
                        'allowDeleteChannels': allow_members_delete_channels,
                        'allowAddRemoveApps': allow_members_add_remove_apps,
                        'allowCreateUpdateRemoveTabs': allow_members_add_remove_tabs,
                        'allowCreateUpdateRemoveConnectors': allow_members_add_remove_connectors,
                    },
                    'messagingSettings': {
                        'allowUserEditMessages': allow_user_edit_messages,
                        'allowUserDeleteMessages': allow_user_delete_messages,
                        'allowOwnerDeleteMessages': allow_owner_delete_messages,
                        'allowTeamMentions': allow_team_mentions,
                        'allowChannelMentions': allow_channel_mentions,
                    },
                },
                resp_type='response',
            )

        @logger
        def list_teams_request(self) -> Dict:
            return self.ms_client.http_request(
                method='GET',
                url_suffix="/beta/groups?$filter=resourceProvisioningOptions/Any(x:x eq 'Team')"
            )

        @logger
        def get_team_request(self, team_id: str) -> Dict:
            return self.ms_client.http_request(
                method='GET',
                url_suffix=f'/v1.0/teams/{team_id}'
            )

        @logger
        def update_team_request(
                self,
                team_id: str,
                display_name: Optional[str] = None,
                description: Optional[str] = None,
                visibility: Optional[str] = None,
                allow_guests_create_channels: Optional[bool] = None,
                allow_guests_delete_channels: Optional[bool] = None,
                allow_members_create_private_channels: Optional[bool] = None,
                allow_members_create_channels: Optional[bool] = None,
                allow_members_delete_channels: Optional[bool] = None,
                allow_members_add_remove_apps: Optional[bool] = None,
                allow_members_add_remove_tabs: Optional[bool] = None,
                allow_members_add_remove_connectors: Optional[bool] = None,
                allow_user_edit_messages: Optional[bool] = None,
                allow_user_delete_messages: Optional[bool] = None,
                allow_owner_delete_messages: Optional[bool] = None,
                allow_team_mentions: Optional[bool] = None,
                allow_channel_mentions: Optional[bool] = None,
        ) -> None:
            self.ms_client.http_request(
                method='PATCH',
                url_suffix=f'/v1.0/teams/{team_id}',
                json_data={
                    'displayName': display_name,
                    'description': description,
                    'visibility': visibility,
                    'guestSettings': {
                        'allowCreateUpdateChannels': allow_guests_create_channels,
                        'allowDeleteChannels': allow_guests_delete_channels,
                    },
                    'memberSettings': {
                        'allowCreatePrivateChannels': allow_members_create_private_channels,
                        'allowCreateUpdateChannels': allow_members_create_channels,
                        'allowDeleteChannels': allow_members_delete_channels,
                        'allowAddRemoveApps': allow_members_add_remove_apps,
                        'allowCreateUpdateRemoveTabs': allow_members_add_remove_tabs,
                        'allowCreateUpdateRemoveConnectors': allow_members_add_remove_connectors,
                    },
                    'messagingSettings': {
                        'allowUserEditMessages': allow_user_edit_messages,
                        'allowUserDeleteMessages': allow_user_delete_messages,
                        'allowOwnerDeleteMessages': allow_owner_delete_messages,
                        'allowTeamMentions': allow_team_mentions,
                        'allowChannelMentions': allow_channel_mentions,
                    },
                },
                resp_type='response',
            )

        @logger
        def delete_team_request(self, team_id: str) -> None:
            self.ms_client.http_request(
                method='DELETE',
                url_suffix=f'/v1.0/groups/{team_id}',
                resp_type='response',
            )

        @logger
        def list_members_request(self, team_id: str) -> Dict:
            return self.ms_client.http_request(
                method='GET',
                url_suffix=f'/v1.0/teams/{team_id}/members',
            )

        @logger
        def get_member_request(self, team_id: str, membership_id: str) -> Dict:
            return self.ms_client.http_request(
                method='GET',
                url_suffix=f'/v1.0/teams/{team_id}/members/{membership_id}',
            )

        @logger
        def add_member_request(self, team_id: str, user_id: str, roles: Optional[list] = None) -> Dict:
            return self.ms_client.http_request(
                method='POST',
                url_suffix=f'/v1.0/teams/{team_id}/members',
                json_data={
                    '@odata.type': '#microsoft.graph.aadUserConversationMember',
                    'roles': roles,
                    'user@odata.bind': f"https://graph.microsoft.com/v1.0/users('{user_id}')",
                },
            )

        @logger
        def remove_member_request(self, team_id: str, membership_id: str) -> None:
            self.ms_client.http_request(
                method='DELETE',
                url_suffix=f'/v1.0/teams/{team_id}/members/{membership_id}',
                resp_type='response',
            )

        @logger
        def update_member_request(self, team_id: str, membership_id: str, roles: Optional[list] = None) -> Dict:
            return self.ms_client.http_request(
                method='PATCH',
                url_suffix=f'/v1.0/teams/{team_id}/members/{membership_id}',
                json_data={
                    '@odata.type': '#microsoft.graph.aadUserConversationMember',
                    'roles': roles,
                },
            )

        @logger
        def archive_team_request(self, team_id: str) -> None:
            self.ms_client.http_request(
                method='POST',
                url_suffix=f'/v1.0/teams/{team_id}/archive',
                resp_type='response',
            )

        @logger
        def unarchive_team_request(self, team_id: str) -> None:
            self.ms_client.http_request(
                method='POST',
                url_suffix=f'/v1.0/teams/{team_id}/unarchive',
                resp_type='response',
            )

        @logger
        def clone_team_request(
                self,
                team_id: str,
                display_name: str,
                description: Optional[str] = None,
                visibility: Optional[str] = None,
                parts_to_clone: Optional[str] = None,
        ) -> None:
            self.ms_client.http_request(
                method='POST',
                url_suffix=f'/v1.0/teams/{team_id}/clone',
                json_data={
                    'displayName': display_name,
                    # from Microsoft docs: "mailNickname property must be specified when a group is created.
                    # If this property is not specified, it will be computed from the displayName.
                    # Known issue: this property is currently ignored."
                    'mailNickname': display_name,
                    'description': description,
                    'visibility': visibility,
                    'partsToClone': parts_to_clone,
                },
                resp_type='response',
            )

        @logger
        def list_joined_teams_request(self, user_id: str) -> Dict:
            return self.ms_client.http_request(
                method='GET',
                url_suffix=f'/v1.0/users/{user_id}/joinedTeams',
            )


    def create_team(client: Client, args: Dict) -> str:
        display_name = args.get('display_name', '')
        client.create_team_request(
            display_name=display_name,
            owner=args.get('owner', ''),
            description=args.get('description'),
            visibility=args.get('visibility', 'public'),
            allow_guests_create_channels=argToBoolean(args.get('allow_guests_create_channels', 'false')),
            allow_guests_delete_channels=argToBoolean(args.get('allow_guests_delete_channels', 'false')),
            allow_members_create_private_channels=argToBoolean(
                args.get('allow_members_create_private_channels', 'false')),
            allow_members_create_channels=argToBoolean(args.get('allow_members_create_channels', 'false')),
            allow_members_delete_channels=argToBoolean(args.get('allow_members_delete_channels', 'false')),
            allow_members_add_remove_apps=argToBoolean(args.get('allow_members_add_remove_apps', 'false')),
            allow_members_add_remove_tabs=argToBoolean(args.get('allow_members_add_remove_tabs', 'false')),
            allow_members_add_remove_connectors=argToBoolean(
                args.get('allow_members_add_remove_connectors', 'false')),
            allow_user_edit_messages=argToBoolean(args.get('allow_user_edit_messages', 'false')),
            allow_user_delete_messages=argToBoolean(args.get('allow_user_delete_messages', 'false')),
            allow_owner_delete_messages=argToBoolean(args.get('allow_owner_delete_messages', 'false')),
            allow_team_mentions=argToBoolean(args.get('allow_team_mentions', 'false')),
            allow_channel_mentions=argToBoolean(args.get('allow_channel_mentions', 'false')),
        )
        return f'Team {display_name} was created successfully.'


    def create_team_from_group(client: Client, args: Dict) -> str:
        group_id = args.get('group_id', '')
        client.create_team_from_group_request(
            group_id=group_id,
            display_name=args.get('display_name'),
            description=args.get('description'),
            visibility=args.get('visibility', 'public'),
            allow_guests_create_channels=argToBoolean(args.get('allow_guests_create_channels', 'false')),
            allow_guests_delete_channels=argToBoolean(args.get('allow_guests_delete_channels', 'false')),
            allow_members_create_private_channels=argToBoolean(
                args.get('allow_members_create_private_channels', 'false')),
            allow_members_create_channels=argToBoolean(args.get('allow_members_create_channels', 'false')),
            allow_members_delete_channels=argToBoolean(args.get('allow_members_delete_channels', 'false')),
            allow_members_add_remove_apps=argToBoolean(args.get('allow_members_add_remove_apps', 'false')),
            allow_members_add_remove_tabs=argToBoolean(args.get('allow_members_add_remove_tabs', 'false')),
            allow_members_add_remove_connectors=argToBoolean(
                args.get('allow_members_add_remove_connectors', 'false')),
            allow_user_edit_messages=argToBoolean(args.get('allow_user_edit_messages', 'false')),
            allow_user_delete_messages=argToBoolean(args.get('allow_user_delete_messages', 'false')),
            allow_owner_delete_messages=argToBoolean(args.get('allow_owner_delete_messages', 'false')),
            allow_team_mentions=argToBoolean(args.get('allow_team_mentions', 'false')),
            allow_channel_mentions=argToBoolean(args.get('allow_channel_mentions', 'false')),
        )
        return f'The team was created from group {group_id} successfully.'


    def list_teams(client: Client) -> CommandResults:
        response = client.list_teams_request()
        teams = response.get('value', [])
        return CommandResults(
            outputs_prefix='MicrosoftTeams.Team',
            outputs_key_field='id',
            readable_output=tableToMarkdown(
                'Microsoft Teams List',
                teams,
                ['id', 'displayName', 'createdDateTime', 'description']
            ),
            outputs=teams,
            raw_response=response,
        )


    def get_team(client: Client, args: Dict) -> CommandResults:
        team_id = args.get('team_id')
        team = client.get_team_request(team_id)
        team.pop('@odata.context', None)
        return CommandResults(
            outputs_prefix='MicrosoftTeams.Team',
            outputs_key_field='id',
            readable_output=tableToMarkdown(f'Team {team_id}', team),
            outputs=team,
        )


    def update_team(client: Client, args: Dict) -> str:
        team_id = args.get('team_id', '')
        update_team_args = {
            'team_id': team_id,
            'display_name': args.get('display_name'),
            'description': args.get('description'),
        }
        for bool_arg in [
            'allow_guests_create_channels', 'allow_guests_delete_channels', 'allow_members_create_private_channels',
            'allow_members_create_channels', 'allow_members_delete_channels', 'allow_members_delete_channels',
            'allow_members_add_remove_apps', 'allow_members_add_remove_tabs', 'allow_members_add_remove_connectors',
            'allow_user_edit_messages', 'allow_user_delete_messages', 'allow_owner_delete_messages',
            'allow_team_mentions', 'allow_channel_mentions'
        ]:
            if bool_arg in args:
                update_team_args[bool_arg] = argToBoolean(args[bool_arg])
        client.update_team_request(**update_team_args)
        return f'Team {team_id} was updated successfully.'


    def delete_team(client: Client, args: Dict) -> str:
        team_id = args.get('team_id')
        client.delete_team_request(team_id)
        return f'Team {team_id} was deleted successfully.'


    def list_members(client: Client, args: Dict) -> CommandResults:
        team_id = args.get('team_id')
        response = client.list_members_request(team_id)
        members = [dict(member, **{'teamId': team_id}) for member in response.get('value', [])]
        return CommandResults(
            outputs_prefix='MicrosoftTeams.TeamMember',
            outputs_key_field='id',
            readable_output=tableToMarkdown(
                f'Team {team_id} Members List',
                members,
                ['id', 'displayName', 'email', 'roles'],
            ),
            outputs=members,
            raw_response=response,
        )


    def get_member(client: Client, args: Dict) -> CommandResults:
        team_id = args.get('team_id')
        membership_id = args.get('membership_id')
        team_member = client.get_member_request(team_id, membership_id)
        team_member['teamId'] = team_id
        return CommandResults(
            outputs_prefix='MicrosoftTeams.TeamMember',
            outputs_key_field='id',
            readable_output=tableToMarkdown(
                f'Team Member {membership_id} Details',
                team_member,
                ['id', 'displayName', 'email', 'roles'],
            ),
            outputs=team_member,
            raw_response=team_member,
        )


    def add_member(client: Client, args: Dict) -> CommandResults:
        team_id = args.get('team_id', '')
        user_id = args.get('user_id', '')
        team_member = client.add_member_request(
            team_id=team_id,
            user_id=user_id,
            roles=['owner'] if argToBoolean(args.get('is_owner', 'false')) else [],
        )
        return CommandResults(
            outputs_prefix='MicrosoftTeams.TeamMember',
            outputs_key_field='id',
            readable_output=tableToMarkdown(
                f'User {user_id} was added to the team {team_id} successfully.',
                team_member,
                ['id', 'displayName', 'email', 'roles'],
            ),
            outputs=team_member,
            raw_response=team_member,
        )


    def remove_member(client: Client, args: Dict) -> str:
        team_id = args.get('team_id')
        membership_id = args.get('membership_id')
        client.remove_member_request(team_id, membership_id)
        return f'Team member {membership_id} was removed from the team {team_id} successfully.'


    def update_member(client: Client, args: Dict) -> CommandResults:
        team_id = args.get('team_id', '')
        membership_id = args.get('membership_id', '')
        team_member = client.update_member_request(
            team_id=team_id,
            membership_id=membership_id,
            roles=['owner'] if argToBoolean(args.get('is_owner', 'false')) else [],
        )
        return CommandResults(
            outputs_prefix='MicrosoftTeams.TeamMember',
            outputs_key_field='id',
            readable_output=tableToMarkdown(
                f'Team member {membership_id} was updated successfully.',
                team_member,
                ['id', 'displayName', 'email', 'roles'],
            ),
            outputs=team_member,
            raw_response=team_member,
        )


    def archive_team(client: Client, args: Dict) -> str:
        team_id = args.get('team_id')
        client.archive_team_request(team_id)
        return f'Team {team_id} was archived successfully.'


    def unarchive_team(client: Client, args: Dict) -> str:
        team_id = args.get('team_id')
        client.unarchive_team_request(team_id)
        return f'Team {team_id} was unarchived successfully.'


    def clone_team(client: Client, args: Dict) -> str:
        team_id = args.get('team_id')
        parts_to_clone = []
        if argToBoolean(args.get('clone_apps', 'true')):
            parts_to_clone.append('apps')
        if argToBoolean(args.get('clone_tabs', 'true')):
            parts_to_clone.append('tabs')
        if argToBoolean(args.get('clone_settings', 'true')):
            parts_to_clone.append('settings')
        if argToBoolean(args.get('clone_channels', 'true')):
            parts_to_clone.append('channels')
        if not parts_to_clone:
            raise ValueError('At least one of the parts of the team must be cloned: apps, tabs, settings, channels')
        client.clone_team_request(
            team_id=team_id,
            display_name=args.get('display_name'),
            description=args.get('description'),
            visibility=args.get('visibility'),
            parts_to_clone=','.join(parts_to_clone),
        )
        return f'Team {team_id} was cloned successfully.'


    def list_joined_teams(client: Client, args: Dict) -> CommandResults:
        user_id = args.get('user_id')
        response = client.list_joined_teams_request(user_id)
        teams = response.get('value', [])
        return CommandResults(
            outputs_prefix='MicrosoftTeams.Team',
            outputs_key_field='id',
            readable_output=tableToMarkdown(
                f'User {user_id} Teams',
                teams,
                ['id', 'displayName', 'description'],
            ),
            outputs=teams,
            raw_response=response,
        )


    def start_auth(client: Client) -> CommandResults:
        result = client.ms_client.start_auth('!microsoft-teams-auth-complete')
        return CommandResults(readable_output=result)


    def complete_auth(client: Client) -> str:
        client.ms_client.get_access_token()
        return '✅ Authorization completed successfully.'


    def test_connection(client: Client) -> str:
        client.ms_client.get_access_token()
        return '✅ Success!'


    def reset_auth() -> CommandResults:
        set_integration_context({})
        return CommandResults(
            readable_output='Authorization was reset successfully. Run **!microsoft-teams-auth-start** to start the '
                            'authentication process.'
        )


    def test_module(client: Client) -> str:
        """Tests API connectivity and authentication for client credentials only.
        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.
        :type client: ``Client``
        :param Client: client to use
        :return: 'ok' if test passed.
        :rtype: ``str``
        """
        # This should validate all the inputs given in the integration configuration panel,
        # either manually or by using an API that uses them.
        if 'Client' not in client.connection_type:
            raise DemistoException(
                "Test module is avilable for Client Credentials only."
                " For other authentication types use the msgraph-apps-auth-start command")

        test_connection(client)
        return "ok"


    def main() -> None:
        params = demisto.params()
        command = demisto.command()
        args = demisto.args()
        handle_proxy()
        demisto.debug(f'Command being called is {command}')
        try:
            client = Client(
                app_id=params.get('app_id', ''),
                verify=not params.get('insecure', False),
                proxy=params.get('proxy', False),
                azure_ad_endpoint=params.get('azure_ad_endpoint',
                                             'https://login.microsoftonline.com') or 'https://login.microsoftonline.com',
                enc_key=(params.get('credentials', {})).get('password'),
                tenant_id=params.get('tenant_id'),
                connection_type=params.get('authentication_type', 'Device Code')
            )
            if command == 'test-module':
                return_results(test_module(client))
            elif command == 'microsoft-teams-auth-start':
                return_results(start_auth(client))
            elif command == 'microsoft-teams-auth-complete':
                return_results(complete_auth(client))
            elif command == 'microsoft-teams-auth-test':
                return_results(test_connection(client))
            elif command == 'microsoft-teams-auth-reset':
                return_results(reset_auth())
            elif command == 'microsoft-teams-team-create':
                return_results(create_team(client, args))
            elif command == 'microsoft-teams-team-create-from-group':
                return_results(create_team_from_group(client, args))
            elif command == 'microsoft-teams-teams-list':
                return_results(list_teams(client))
            elif command == 'microsoft-teams-team-get':
                return_results(get_team(client, args))
            elif command == 'microsoft-teams-team-update':
                return_results(update_team(client, args))
            elif command == 'microsoft-teams-team-delete':
                return_results(delete_team(client, args))
            elif command == 'microsoft-teams-members-list':
                return_results(list_members(client, args))
            elif command == 'microsoft-teams-member-get':
                return_results(get_member(client, args))
            elif command == 'microsoft-teams-member-add':
                return_results(add_member(client, args))
            elif command == 'microsoft-teams-member-remove':
                return_results(remove_member(client, args))
            elif command == 'microsoft-teams-member-update':
                return_results(update_member(client, args))
            elif command == 'microsoft-teams-team-archive':
                return_results(archive_team(client, args))
            elif command == 'microsoft-teams-team-unarchive':
                return_results(unarchive_team(client, args))
            elif command == 'microsoft-teams-team-clone':
                return_results(clone_team(client, args))
            elif command == 'microsoft-teams-teams-list-joined':
                return_results(list_joined_teams(client, args))
            else:
                raise NotImplementedError(f'Command "{command}" is not implemented.')
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}', e)


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Microsoft Teams Management', 'end', __line__())
  subtype: python3
  type: python
system: true
