category: Data Enrichment & Threat Intelligence
commonfields:
  id: Agari Phishing Defense
  version: -1
configuration:
- defaultvalue: https://api.agari.com/v1/ep
  display: URL to connect to Agari
  name: url
  required: true
  type: 0
- additionalinfo: API Client ID created in the User management UI.
  display: API Key
  name: apikey
  required: true
  type: 4
- additionalinfo: API Client Secret created in the User management UI.
  display: Secret Key
  name: apisecret
  required: true
  type: 4
- defaultvalue: "50"
  display: Maximum number of incidents to fetch every time
  name: max_fetch
  required: true
  type: 0
- additionalinfo: The time range to consider for the initial data fetch. (<number>
    <unit>, e.g., 2 minutes, 2 hours, 2 days, 2 months, 2 years). Default is 3 days.
  defaultvalue: 3 days
  display: First fetch time interval
  name: first_fetch
  required: false
  type: 0
- additionalinfo: Apply the filter to fetch policy events having actions such as "deliver",
    "mark-spam", "move", "inbox", "delete", "none". Fetches all types of actions by
    default.
  display: Policy action taken
  name: fetch_policy_actions
  options:
  - deliver
  - mark-spam
  - move
  - inbox
  - delete
  - none
  required: false
  type: 15
- additionalinfo: Exclude alerts while fetching policy events of type 'Message Alert'
    or 'System Alert'.
  defaultvalue: System Alert
  display: Exclude alerts
  name: exclude_alert_type
  options:
  - System Alert
  - Message Alert
  required: false
  type: 15
- additionalinfo: "Syntax: field.operator(operand) {and/or field.operator(operand)}
    \n\nExample: created_at.after(2020-11-11T09:16:44Z) or id.eq(537557694)"
  display: Fetches policy events as per the filter to limit the amount of data. Can
    be applied to specific fields.
  name: policy_filter
  required: false
  type: 12
- defaultvalue: Agari Phishing Defense Policy Event
  display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.1.3
    packID: AgariPhishingDefense
    packName: Agari Phishing Defense
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Agari Phishing Defense stops phishing, BEC, and other identity deception
  attacks that trick employees into harming your business.
detaileddescription: "### Partner Contributed Integration\n#### Integration Author:
  Agari\nSupport and maintenance for this integration are provided by the author.
  Please use the following contact details:\n- **Email**: [support@agari.com](mailto:support@agari.com)\n-
  **URL**: [https://www.agari.com/support/](https://www.agari.com/support/)\n***\n##
  Agari Phishing Defense\n- To use this integration, simply follow the [Quick Start](https://developers.agari.com/agari-platform/docs/quick-start)
  steps to enable API access.\n- [Contact us](https://www.agari.com/contact-us/) if
  you don't have an Agari account.\n\n##### Syntax to filter policy events\n- To filter
  by applying the valid syntax you can refer to [this](https://developers.agari.com/agari-platform/docs/filtering)
  page. \n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/agari-phishing-defense)"
display: Agari Phishing Defense (Partner Contribution)
image: data:image/png;base64,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
name: Agari Phishing Defense
script:
  commands:
  - arguments:
    - defaultValue: "25"
      description: The maximum number of items to be returned in the paged response.
      name: limit
    - description: |-
        The earliest date time (UTC) a search should target (ISO 8601 format).
        Formats accepted: YYYY-MM-dd
        YYYY-MM-ddTHH:mm:ss
        N days
        N hours
        Example: 2020-05-01
        2020-05-01T00:00:00
        2 days
        5 hours.
      name: start_date
    - description: "The latest date time (UTC) a search should target (ISO 8601 format).\nFormats
        accepted: YYYY-MM-dd\nYYYY-MM-ddTHH:mm:ss\nN days\nN hours\nExample: 2020-05-01
        \n2020-05-01T00:00:00\n2 days\n5 hours."
      name: end_date
    - defaultValue: "1"
      description: To page through a collection of policy events.
      name: page_id
    - description: 'A comma-delimited string that specifies the field ordering to
        be applied to the response. Example: created_at DESC, id ASC.'
      isArray: true
      name: sort
    - description: A comma-delimited list of optional fields to add to the default
        payload. Additional fields would add data in the entry context.
      isArray: true
      name: add_fields
    - description: A comma-delimited list of fields to remove from the default payload.
        Limited fields would return limited data in entry context.
      isArray: true
      name: rem_fields
    - description: A comma-delimited list of fields to include in the payload. Limited
        fields would return limited data in entry context.
      isArray: true
      name: fields
    - description: Search filters that can be applied to the response.
      name: filter
    - description: Exclude policy types such as 'MessageAlert' or 'SystemAlert'.
      name: exclude_alert_types
    - description: Find by policy name.
      name: policy_name
    - auto: PREDEFINED
      description: 'Filter by policy action: ''deliver'', ''mark-spam'', ''move'',
        ''inbox'', ''delete'' and ''none''.'
      name: policy_action
      predefined:
      - deliver
      - mark-spam
      - move
      - inbox
      - delete
      - none
    description: Retrieves a list of policy events.
    name: apd-list-policy-events
    outputs:
    - contextPath: AgariPhishingDefense.Alert.alert_definition_name
      description: Alert definition name.
      type: String
    - contextPath: AgariPhishingDefense.Alert.id
      description: Unique alert id.
      type: String
    - contextPath: AgariPhishingDefense.Alert.summary
      description: Summary of the alert.
      type: String
    - contextPath: AgariPhishingDefense.Alert.policy_action
      description: Alert policy action.
      type: String
    - contextPath: AgariPhishingDefense.Alert.policy_enabled
      description: Indicates if policy is enabled.
      type: Boolean
    - contextPath: AgariPhishingDefense.Alert.updated_at
      description: Updated time of the alert. The format is ISO8601.
      type: Date
    - contextPath: AgariPhishingDefense.Alert.created_at
      description: Created time of the alert. The format is ISO8601.
      type: Date
    - contextPath: AgariPhishingDefense.Alert.admin_recipients
      description: List of notified admin recipients.
      type: Unknown
    - contextPath: AgariPhishingDefense.Alert.notified_original_recipients
      description: Indicates whether the original recipient was notified.
      type: Boolean
  - arguments:
    - description: "The earliest date time (UTC) a search should target (ISO 8601
        format).\nFormats accepted: YYYY-MM-dd\nYYYY-MM-ddTHH:mm:ss\nN days\nN hours\nExample:
        2020-05-01 \n2020-05-01T00:00:00\n2 days\n5 hours."
      name: start_date
    - description: "The latest date time (UTC) a search should target (ISO 8601 format).\nFormats
        accepted: YYYY-MM-dd\nYYYY-MM-ddTHH:mm:ss\nN days\nN hours\nExample: 2020-05-01
        \n2020-05-01T00:00:00\n2 days\n5 hours."
      name: end_date
    - description: A comma-delimited list of optional fields to add to the default
        payload. Additional fields would add data in the entry context.
      isArray: true
      name: add_fields
    - description: A comma-delimited list of fields to remove from the default payload.
        Limited fields would return limited data in entry context.
      isArray: true
      name: rem_fields
    - description: A comma-delimited list of fields to include in the payload. Limited
        fields would return limited data in entry context.
      isArray: true
      name: fields
    - defaultValue: "25"
      description: The maximum number of items to be returned in the paged response.
      name: limit
    - defaultValue: "1"
      description: To page through a collection of message data.
      name: page_id
    - description: A comma-delimited string that specifies the field ordering to be
        applied to the response.
      isArray: true
      name: sort
    - description: |-
        Search using advanced search syntax.
        Format: field operator operand {and/or field operator operand}
        Example: has_attachment=true and ip='10.0.0.0'
        sbrs in [3.5, 2.6]
        domain_reputation is not null
        sbrs gt 3
        sbrs>=3 and domain_tags eq internal
      name: search
    description: Retrieves a list of messages.
    name: apd-list-message-data
    outputs:
    - contextPath: AgariPhishingDefense.Message.has_attachment
      description: Has attachment.
      type: Boolean
    - contextPath: AgariPhishingDefense.Message.ip
      description: IP address.
      type: String
    - contextPath: AgariPhishingDefense.Message.message_id
      description: The Global message ID.
      type: String
    - contextPath: AgariPhishingDefense.Message.ptr_name
      description: A Pointer Record to get the associated domain/hostname.
      type: String
    - contextPath: AgariPhishingDefense.Message.sbrs
      description: SBRS.
      type: String
    - contextPath: AgariPhishingDefense.Message.id
      description: The internal message ID.
      type: String
    - contextPath: AgariPhishingDefense.Message.authenticity
      description: Authenticity score.
      type: Number
    - contextPath: AgariPhishingDefense.Message.to
      description: Message recipient.
      type: String
    - contextPath: AgariPhishingDefense.Message.date
      description: Date in ISO format.
      type: String
    - contextPath: AgariPhishingDefense.Message.timestamp_ms
      description: Timestamp in ms since epoch.
      type: Number
    - contextPath: AgariPhishingDefense.Message.from
      description: Sender's email.
      type: String
    - contextPath: AgariPhishingDefense.Message.from_domain
      description: From domain.
      type: String
    - contextPath: AgariPhishingDefense.Message.subject
      description: Message subject.
      type: String
    - contextPath: AgariPhishingDefense.Message.domain_reputation
      description: Reputation of sender domain.
      type: Number
    - contextPath: AgariPhishingDefense.Message.message_trust_score
      description: Risk score.
      type: Number
    - contextPath: AgariPhishingDefense.Message.message_details_link
      description: Link to message details.
      type: String
    - contextPath: AgariPhishingDefense.Message.domain_tags
      description: List of domain tags.
      type: Unknown
    - contextPath: AgariPhishingDefense.Message.mail_from
      description: Mail from domain.
      type: String
    - contextPath: AgariPhishingDefense.Message.reply_to
      description: Reply-to address.
      type: String
    - contextPath: AgariPhishingDefense.Message.uris
      description: List of URIs.
      type: Unknown
    - contextPath: AgariPhishingDefense.Message.attachment_extensions
      description: List of message attachment extensions.
      type: Unknown
    - contextPath: AgariPhishingDefense.Message.attachment_filenames
      description: List of message attachment filenames.
      type: Unknown
    - contextPath: AgariPhishingDefense.Message.attachment_sha256
      description: List of message attachment SHA256 hashes.
      type: Unknown
    - contextPath: AgariPhishingDefense.Message.attachment_types
      description: List of message attachment types.
      type: Unknown
    - contextPath: AgariPhishingDefense.Message.attack_types
      description: List of attack type classifications.
      type: Unknown
    - contextPath: AgariPhishingDefense.Message.dkim_result
      description: DKIM result.
      type: String
    - contextPath: AgariPhishingDefense.Message.dmarc_result
      description: DMARC result.
      type: String
    - contextPath: AgariPhishingDefense.Message.domain_dmarc_policy
      description: DMARC policy for domain.
      type: String
    - contextPath: AgariPhishingDefense.Message.enforcement_action
      description: Enforcement action.
      type: String
    - contextPath: AgariPhishingDefense.Message.enforcement_folder
      description: Enforcement folder.
      type: String
    - contextPath: AgariPhishingDefense.Message.enforcement_result
      description: Enforcement result.
      type: String
    - contextPath: AgariPhishingDefense.Message.expanded_from
      description: Expanded from.
      type: String
    - contextPath: AgariPhishingDefense.Message.forwarded_from
      description: Forwarded from.
      type: String
    - contextPath: AgariPhishingDefense.Message.has_malicious_attachment
      description: Has malicious attachment.
      type: Boolean
    - contextPath: AgariPhishingDefense.Message.message_read_status
      description: Message read status.
      type: Boolean
    - contextPath: AgariPhishingDefense.Message.org_domain
      description: Organization domain.
      type: String
    - contextPath: AgariPhishingDefense.Message.policy_ids
      description: List of triggered policy IDs.
      type: Unknown
    - contextPath: AgariPhishingDefense.Message.sender_approval_state
      description: Sender approval state.
      type: String
    - contextPath: AgariPhishingDefense.Message.sender_type
      description: Sender type.
      type: String
    - contextPath: AgariPhishingDefense.Message.spf_result
      description: SPF result.
      type: String
  - arguments:
    - description: The primary identifier to remediate a message (UUID). To retrieve
        the ID execute the apd-list-message-data command.
      name: id
      required: true
    - auto: PREDEFINED
      description: An operation to remediate a message. Remediation operation is either
        'delete' or 'move'.
      name: operation
      predefined:
      - delete
      - move
      required: true
    description: Remediate suspected message.
    name: apd-remediate-message
  dockerimage: demisto/python3:3.10.9.40422
  isfetch: true
  runonce: false
  script: |
    register_module_line('Agari Phishing Defense', 'start', __line__())




    """ IMPORTS """

    import dateparser
    from requests import Response
    from typing import Dict, Any, Union, Tuple
    from requests.exceptions import (
        MissingSchema,
        InvalidSchema,
        InvalidURL,
        SSLError,
    )
    from concurrent.futures import ThreadPoolExecutor, as_completed
    import threading
    import urllib3

    urllib3.disable_warnings()

    """ CONSTANTS """

    MAX_LIMIT_FOR_EVENT = 200
    MAX_LIMIT_FOR_MESSAGE = 1000
    DEFAULT_FETCH_LIMIT = '50'
    DEFAULT_FIRST_FETCH = '12 hours'
    DEFAULT_SESSION_TIMEOUT = 30
    TOKEN_EXPIRY_TIMEOUT = 60 * 60 * 4
    CONTENT_TYPE_JSON = 'application/json'
    DATE_FORMAT_OF_YEAR_MONTH_DAY = '%Y-%m-%d'
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    DATE_FORMAT_WITH_MICROSECOND = '%Y-%m-%dT%H:%M:%S.%fZ'
    API_SUPPORT_DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.000-00:00'
    API_VERSION = 'v1'
    MAX_WORKERS = 5
    TOKEN_TIME_DIFF = 60
    INTEGRATION_VERSION = 'v1.0'

    URL_SUFFIX: Dict[str, str] = {
        'GET_TOKEN': '/token',
        'GET_EVENTS': '/policy_events',
        'REMEDIATE_MSG': '/messages/{}/remediate',
        'GET_MESSAGES': '/messages',
    }

    MESSAGES: Dict[str, str] = {
        'BAD_REQUEST_ERROR': 'An error occurred while fetching the data.',
        'AUTHENTICATION_ERROR': 'Unauthenticated. Check the configured API Key and Secret Key.',
        'PROXY_ERROR': "Proxy Error - cannot connect to proxy. Either try clearing the 'Use system proxy' check-box or "
        'check the host, authentication details and connection details for the proxy.',
        'SSL_CERT_ERROR': "SSL Certificate Verification Failed - try selecting 'Trust any certificate' checkbox in the "
        'integration configuration.',
        'INTERNAL_SERVER_ERROR': 'The server encountered an internal error for Agari and was unable to complete '
        'your request.',
        'MISSING_SCHEMA_ERROR': 'Invalid API URL. No schema supplied: http(s).',
        'INVALID_SCHEMA_ERROR': 'Invalid API URL. Supplied schema is invalid, supports http(s).',
        'INVALID_API_URL': 'Invalid API URL.',
        'CONNECTION_ERROR': 'Connectivity failed. Check your internet connection or the API URL.',
        'NO_RECORDS_FOUND': 'No {} were found for the given argument(s).',
        'FETCH_LIMIT_VALIDATION': 'Value of Fetch Limit must be a positive integer between 1 to 200.',
        'REQUEST_TIMEOUT': 'Request timed out. Check the configured HTTP(S) Request Timeout (in seconds) value.',
        'INVALID_TIME_VALIDATION': 'The given value for {0} argument is invalid.',
        'INVALID_POLICY_ACTION_TYPE': 'The given value for Policy Actions is invalid. Expected "deliver", "mark-spam", '
        '"move", "inbox", "delete" or "none". ',
        'INVALID_LIMIT': 'Argument limit must be a positive integer between 1 to {}.',
        'INVALID_PAGE_ID': 'Argument page_id must be a positive integer.',
        'INVALID_REM_FIELDS': 'Cannot pass "id" in rem_fields argument.',
        'MISSING_REMEDIATE_ARGS': 'Invalid argument value. Requires both "id" and "operation" argument.',
        'INVALID_EXCLUDE_ALERT_TYPE': 'The given value for Exclude Alerts is invalid. Expected "System Alert" or '
        '"Message Alert". ',
    }

    HR_MESSAGES: Dict[str, str] = {
        'REMEDIATE_MSG_SUCCESS': "Message ID - {} remediated successfully with operation '{}'."
    }


    def strip_blank(args: dict) -> dict:
        nargs = {}
        for key, value in args.items():
            if isinstance(value, str):
                value = value.strip()
            nargs[key] = value
        return nargs


    """ CLIENT CLASS """


    class Client(BaseClient):
        def __init__(
            self,
            base_url: str,
            verify: bool,
            proxy: bool,
            request_timeout: int,
            payload,
        ):
            """
            Initialization of HTTP request timeout, payload(i.e client id and client secret)
            Initialization of lock object and create a token for the first time if not available in context

            :param base_url: Base url of Endpoint
            :param verify: Whether the request should verify the SSL certificate.
            :param proxy: Whether to run the integration using the system proxy.
            :param request_timeout: Time of Request Timeout
            :param payload: Payload data (i.e client id and client secret)
            """
            super().__init__(base_url=base_url, verify=verify, proxy=proxy)
            self.request_timeout = request_timeout
            self.payload = payload
            self.lock = threading.Lock()
            self.api_token, self.api_token_valid_until = self.get_api_token()

        def http_request(
            self,
            method: str,
            url_suffix: str,
            json_data=None,
            params=None,
            headers=None,
            data=None,
        ):
            """
                Override http_request method from BaseClient class. This method will print an error based on status code
                and exceptions.

            :type method: ``str``
            :param method: The HTTP method, for example: GET, POST, and so on.

            :type url_suffix: ``str``
            :param url_suffix: The API endpoint.

            :type json_data: ``dict``
            :param json_data: The dictionary to send in a 'POST' request.

            :type params: ``dict``
            :param params: URL parameters to specify the query.

            :type headers: ``dict``
            :param headers: Headers to send in the request. If None, will use self._headers.

            :return: Depends on the resp_type parameter
            :rtype: ``dict`` or ``str`` or ``requests.Response``
            """

            resp = Response()
            try:
                if url_suffix != URL_SUFFIX['GET_TOKEN']:
                    with self.lock:
                        if (
                            int(time.time() + TOKEN_TIME_DIFF)
                            >= self.api_token_valid_until
                        ):
                            (
                                self.api_token,
                                self.api_token_valid_until,
                            ) = self.get_api_token()
                # pylint: disable=E1101
                headers['User-Agent'] = (
                    'AgariDemisto APDIntegration/'
                    + INTEGRATION_VERSION
                    + ' DemistoServer/'
                    + demisto.demistoVersion()['version']
                )  # type: ignore[attr-defined]
                # pylint: enable=E1101
                resp = super()._http_request(
                    method=method,
                    url_suffix=url_suffix,
                    json_data=json_data,
                    params=params,
                    headers=headers,
                    resp_type='response',
                    timeout=self.request_timeout,
                    ok_codes=(200, 201),
                    error_handler=self.handle_error_response,
                    data=data,
                )
            except MissingSchema:
                raise ValueError(MESSAGES['MISSING_SCHEMA_ERROR'])
            except InvalidSchema:
                raise ValueError(MESSAGES['INVALID_SCHEMA_ERROR'])
            except InvalidURL:
                raise ValueError(MESSAGES['INVALID_API_URL'])
            except DemistoException as e:
                self.handle_demisto_exception(e)

            if resp.ok:
                content_type = resp.headers.get('Content-Type', '')
                if content_type.__contains__(CONTENT_TYPE_JSON):
                    # Handle empty response
                    if resp.text == '':
                        return resp
                    else:
                        return resp.json()
                else:
                    return resp

        @staticmethod
        def handle_demisto_exception(e) -> None:
            """
            Handle Demisto exception based on string.

            :param e: Demisto Exception
            :return: Error message
            """
            if 'Proxy Error' in str(e):
                raise ConnectionError(MESSAGES['PROXY_ERROR'])
            elif 'ReadTimeoutError' in str(e):
                raise ConnectionError(MESSAGES['REQUEST_TIMEOUT'])
            elif 'ConnectionError' in str(e) or 'ConnectTimeoutError' in str(e):
                raise ConnectionError(MESSAGES['CONNECTION_ERROR'])
            elif 'SSLError' in str(e):
                raise SSLError(MESSAGES['SSL_CERT_ERROR'])
            else:
                raise e

        @staticmethod
        def handle_error_response(resp) -> None:
            """
            Handle error response and display user specific error message based on status code.

            :param resp: response from API.
            :return: raise DemistoException based on status code.
            """

            error_message = ''
            error_message_with_reason = ''
            try:
                json_resp = resp.json()
                error_message = json_resp['error']
                error_message_with_reason = json_resp['error_description']
            except Exception:  # ignoring json parsing errors
                pass

            status_code_messages = {
                400: f"{MESSAGES['BAD_REQUEST_ERROR']} {error_message_with_reason}",
                401: MESSAGES['AUTHENTICATION_ERROR'],
                403: error_message,
                404: f"{MESSAGES['BAD_REQUEST_ERROR']} {error_message_with_reason}",
                406: error_message,
                407: MESSAGES['PROXY_ERROR'],
                500: MESSAGES['INTERNAL_SERVER_ERROR'],
                503: MESSAGES['INTERNAL_SERVER_ERROR'],
            }

            if resp.status_code in status_code_messages:
                demisto.debug(
                    f'Response Code: {resp.status_code}, Reason: {status_code_messages[resp.status_code]}'
                )
                raise DemistoException(status_code_messages[resp.status_code])
            else:
                raise DemistoException(resp.raise_for_status())

        @staticmethod
        def set_integration_context(resp) -> dict:
            """
            set api token and expiry time in integration configuration context.
            Will raise value error if api-token is not found.

            :param resp: resp from API.
            :return: integration context
            """

            integration_context = demisto.getIntegrationContext()
            api_token = resp['access_token']
            if api_token:
                integration_context['api_token'] = 'Bearer ' + api_token
                integration_context['valid_until'] = int(
                    time.time() + TOKEN_EXPIRY_TIMEOUT
                )
            else:
                raise ValueError('No api token found. Please try again')
            demisto.setIntegrationContext(integration_context)
            return integration_context

        def get_api_token(self):
            """
            Retrieve new api token and set it to integration context.
            if api token is not not found or expired, making api call to retrieve api token and set it to integration
            context.

            :return: api-token, validity of token
            """
            integration_context = demisto.getIntegrationContext()
            api_token = integration_context.get('api_token')
            valid_until = integration_context.get('valid_until')

            # Return api token from integration context, if found and not expired
            if (
                api_token
                and valid_until
                and time.time() + TOKEN_TIME_DIFF < valid_until
            ):
                demisto.debug('Retrieved api-token from integration cache.')
                return api_token, valid_until

            headers = {
                'Accept': CONTENT_TYPE_JSON,
                'Content-Type': 'application/x-www-form-urlencoded',
            }

            demisto.debug('Calling authentication API for retrieve api-token')
            resp = self.http_request(
                method='POST',
                url_suffix=URL_SUFFIX['GET_TOKEN'],
                headers=headers,
                data=self.payload,
            )

            integration_context = self.set_integration_context(resp)

            return integration_context.get('api_token'), int(
                integration_context.get('valid_until', 0)
            )


    def get_fetch_limit(fetch_limit) -> int:
        """
        Retrieve fetch limit from demisto arguments and validate it.
        Will raise ValueError if inappropriate input given.

        :param fetch_limit: The maximum number of incident want to fetch.
        :return: fetch limit
        """
        fetch_limit = DEFAULT_FETCH_LIMIT if not fetch_limit else fetch_limit
        try:
            fetch_limit_int = int(fetch_limit)
            if not 1 <= fetch_limit_int <= 200:
                raise ValueError
        except ValueError:
            raise ValueError(MESSAGES['FETCH_LIMIT_VALIDATION'])

        return fetch_limit_int


    def validate_fetch_policy_action(fetch_policy_action) -> bool:
        """
        Validate fetch policy action.

        :param fetch_policy_action: A list contain policy actions which user want to fetch.
        :return: True if it is valid
        """
        policy_actions = [
            'deliver',
            'mark-spam',
            'move',
            'inbox',
            'delete',
            'none',
        ]
        if fetch_policy_action == '' or fetch_policy_action is None:
            return True

        if not (fetch_policy_action in policy_actions):
            raise ValueError(MESSAGES['INVALID_POLICY_ACTION_TYPE'])
        return False


    def validate_exclude_alert_type(exclude_alert_type) -> bool:
        """
        Validate exclude alert type.

        :param exclude_alert_type: A list contain exclude alert types which user want to exclude.
        :return: True if it is valid
        """

        exclude_alert_types = ['System Alert', 'Message Alert']
        if exclude_alert_type == '' or exclude_alert_type is None:
            return True

        if not (exclude_alert_type in exclude_alert_types):
            raise ValueError(MESSAGES['INVALID_EXCLUDE_ALERT_TYPE'])
        return False


    def prepare_hr_for_events(events_info) -> str:
        """
        Prepare the Human readable info for events command.

        :param events_info: The events data.
        :return: Human readable.
        """
        hr_list = []
        for record in events_info:
            hr_record = {
                'Event ID': record.get('id', None),
                'Alert Definition Name': record.get('alert_definition_name', ''),
                'Created': record.get('created_at', ''),
                'Updated': record.get('updated_at', ''),
                'Policy Action': record.get('policy_action', ''),
                'Notified Original Recipients': record.get(
                    'notified_original_recipients', ''
                ),
                'Admin Recipients': record.get('admin_recipients', ''),
            }
            hr_list.append(hr_record)

        return tableToMarkdown(
            'Policy Events',
            hr_list,
            [
                'Event ID',
                'Alert Definition Name',
                'Policy Action',
                'Notified Original Recipients',
                'Admin Recipients',
                'Created',
                'Updated',
            ],
            removeNull=True,
        )


    def prepare_hr_for_messages(messages_info) -> str:
        """
        Prepare the Human readable info for messages data command.

        :param messages_info: The messages data.
        :return: Human readable.
        """
        hr_list = []
        for record in messages_info:
            hr_record = {
                'ID': record.get('id', ''),
                'From': record.get('from', ''),
                'To': record.get('to', ''),
                'Subject': record.get('subject', ''),
                'Message Trust Score': record.get('message_trust_score', ''),
                'Domain Reputation': record.get('domain_reputation', ''),
                'IP': record.get('ip', ''),
                'Authenticity': record.get('authenticity', ''),
                'Attachment Filenames': record.get('attachment_filenames', ''),
                'Attachment sha256': record.get('attachment_sha256', ''),
                'Attack Types': record.get('attack_types', ''),
                'Date': record.get('date', ''),
            }
            hr_list.append(hr_record)

        return tableToMarkdown(
            'Messages',
            hr_list,
            [
                'ID',
                'From',
                'To',
                'Subject',
                'Message Trust Score',
                'Domain Reputation',
                'IP',
                'Authenticity',
                'Attachment Filenames',
                'Attachment sha256',
                'Attack Types',
                'Date',
            ],
            removeNull=True,
        )


    def test_function(**kwargs) -> str:
        """
        Performs test connectivity by valid http response.

        :param kwargs: Contains all required parameters.
        :return: raise ValueError if any error occurred during connection
        """
        headers = {
            'Accept': CONTENT_TYPE_JSON,
            'Content-Type': 'application/x-www-form-urlencoded',
        }
        client = kwargs['client']
        res = client.http_request(
            method='POST',
            url_suffix=URL_SUFFIX['GET_TOKEN'],
            headers=headers,
            data=client.payload,
        )
        if not res['access_token']:
            return 'Invalid API Key, Secret Key or URL'

        if kwargs['is_fetch']:
            get_fetch_limit(kwargs['fetch_limit'])

            # getting numeric value from string representation
            start_time, _ = parse_date_range(
                kwargs['first_fetch_time'], date_format=DATE_FORMAT, utc=True
            )

            # validate policy actions

            validate_fetch_policy_action(kwargs['fetch_policy_actions'])

            # validate exclude alerts

            validate_exclude_alert_type(kwargs['exclude_alert_type'])
            kwargs['exclude_alert_type'] = kwargs['exclude_alert_type'].replace(
                ' ', ''
            )
            fetch_incidents(client, {}, {}, True)

        return 'ok'


    def get_events_params(
        args: Dict[str, Any], max_record=MAX_LIMIT_FOR_EVENT
    ) -> Dict[str, Any]:
        """
        Validates the input arguments of command and returns parameter dictionary
        or raises ValueError in case of validation failed.

        :param args: Input arguments of command
        :param max_record: Maximum fetch limit
        :return: Params dict or error message
        """

        arg_keys = args.keys()

        if 'rem_fields' in arg_keys:
            values = args.get('rem_fields', '').split(',')
            if 'id' in values:
                raise ValueError(MESSAGES['INVALID_REM_FIELDS'])

        if 'start_date' in arg_keys:
            start_date = args.get('start_date', '')
            if start_date.isdigit():
                raise ValueError(
                    MESSAGES['INVALID_TIME_VALIDATION'].format('start_date')
                )
            date_time = dateparser.parse(
                start_date, settings={'STRICT_PARSING': True}
            )
            if date_time:
                args['start_date'] = str(
                    date_time.strftime(API_SUPPORT_DATE_FORMAT)
                )
            else:
                raise ValueError(
                    MESSAGES['INVALID_TIME_VALIDATION'].format('start_date')
                )

        if 'end_date' in arg_keys:
            end_date = args.get('end_date', '')
            if end_date.isdigit():
                raise ValueError(
                    MESSAGES['INVALID_TIME_VALIDATION'].format('end_date')
                )
            date_time = dateparser.parse(
                end_date, settings={'STRICT_PARSING': True}
            )
            if date_time:
                args['end_date'] = str(date_time.strftime(API_SUPPORT_DATE_FORMAT))
            else:
                raise ValueError(
                    MESSAGES['INVALID_TIME_VALIDATION'].format('end_date')
                )

        limit = 25
        if 'limit' in arg_keys:
            try:
                limit = int(args.get('limit', 25))
                if not (1 <= limit <= max_record):
                    raise ValueError(MESSAGES['INVALID_LIMIT'].format(max_record))
            except ValueError:
                raise ValueError(MESSAGES['INVALID_LIMIT'].format(max_record))

        if 'page_id' in arg_keys:
            try:
                page_id = int(args.get('page_id', 1))
                page_id -= 1
                if page_id < 0:
                    raise ValueError(MESSAGES['INVALID_PAGE_ID'])
            except ValueError:
                raise ValueError(MESSAGES['INVALID_PAGE_ID'])

            offset = page_id * limit
            args['offset'] = offset
            args.__delitem__('page_id')

        return args


    def list_policy_events_command(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Retrieve list of events based on various argument(s).
        Will raise an exception if validation fails.

        :param client: Client object
        :param args: The command arguments provided by user.
        :return: Standard command result or no records found message
        """

        # Validate arguments
        params = get_events_params(args, MAX_LIMIT_FOR_EVENT)

        resp = get_list_policies_api_endpoint(client, params)

        total_records = resp['alert_events']
        if not total_records:
            return MESSAGES['NO_RECORDS_FOUND'].format('event(s)')

        # Creating entry context
        custom_ec_for_event = remove_empty_elements(total_records)

        # Creating human-readable
        hr = prepare_hr_for_events(total_records)

        return CommandResults(
            outputs_prefix='AgariPhishingDefense.Alert',
            outputs_key_field='id',
            outputs=custom_ec_for_event,
            readable_output=hr,
            raw_response=resp,
        )


    def list_message_data_command(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Retrieve list of messages based on various argument(s).
        Will raise an exception if validation fails.

        :param client: Client object
        :param args: The command arguments provided by user.
        :return: Standard command result or no records found message
        """

        # Validate arguments
        params = get_events_params(args, MAX_LIMIT_FOR_MESSAGE)

        # Preparing header

        headers = {'Authorization': client.api_token, 'Accept': CONTENT_TYPE_JSON}

        # http call
        resp = client.http_request(
            method='GET',
            url_suffix=URL_SUFFIX['GET_MESSAGES'],
            params=params,
            headers=headers,
        )

        total_records = resp['messages']
        if not total_records:
            return MESSAGES['NO_RECORDS_FOUND'].format('event(s)')

        # Creating entry context
        custom_ec_for_message = remove_empty_elements(total_records)

        # Creating human-readable
        hr = prepare_hr_for_messages(total_records)

        return CommandResults(
            outputs_prefix='AgariPhishingDefense.Message',
            outputs_key_field='id',
            outputs=custom_ec_for_message,
            readable_output=hr,
            raw_response=resp,
        )


    def remediate_message_command(
        client: Client, args: Dict[str, Any]
    ) -> CommandResults:
        """
        Remediate a message by applying a remediation operation 'move' or 'delete'.

        :param client: Client object
        :param args: The command arguments provided by user.
        :return: Standard command result or raise Exception
        """
        # Validate arguments
        message_id, action = (
            args.get('id', '').strip(),
            args.get('operation', '').strip(),
        )

        if not message_id or not action:
            raise ValueError(MESSAGES['MISSING_REMEDIATE_ARGS'])

        body = {'operation': action.lower()}

        headers = {'Authorization': client.api_token, 'Accept': CONTENT_TYPE_JSON}

        # http call
        client.http_request(
            method='POST',
            url_suffix=URL_SUFFIX['REMEDIATE_MSG'].format(message_id),
            json_data=body,
            headers=headers,
        )

        return CommandResults(
            readable_output=HR_MESSAGES['REMEDIATE_MSG_SUCCESS'].format(
                message_id, action
            )
        )


    def get_list_policies_api_endpoint(
        client: Client, params: Dict[str, Any]
    ) -> Any:
        """
        This function gets list of policies

        :param client: Client object
        :param params: Parameters to be passed in API call

        :return response: Response of API call of list all policies
        """
        # Preparing header
        headers = {'Authorization': client.api_token, 'Accept': CONTENT_TYPE_JSON}

        # http call
        return client.http_request(
            method='GET',
            url_suffix=URL_SUFFIX['GET_EVENTS'],
            params=params,
            headers=headers,
        )


    def fetch_incidents_params(**kwargs) -> Dict[str, Any]:
        """
        Validates the input arguments of integration for fetching incidents and returns parameter dictionary
        or raises ValueError in case of validation failed.

        :param kwargs: Input arguments of integration to fetch incidents
        :return: params dict or error message
        """
        params = {
            'start_date': kwargs['start_date'],
            'sort': 'created_at ASC,id ASC',
        }

        if kwargs['id'] is not None and kwargs['id'] != '':
            params['filter'] = 'id.gt(+' + str(kwargs['id']) + ')'
            if (
                kwargs['policy_filter'] is not None
                and kwargs['policy_filter'] != ''
            ):
                params['filter'] = (
                    kwargs['policy_filter'] + ' and ' + params['filter']
                )
        elif kwargs['policy_filter'] is not None and kwargs['policy_filter'] != '':
            params['filter'] = kwargs['policy_filter']

        if kwargs['fetch_limit'] is not None and kwargs['fetch_limit'] != '':
            params['limit'] = get_fetch_limit(kwargs['fetch_limit'])

        if (
            kwargs['fetch_policy_actions'] is not None
            and kwargs['fetch_policy_actions'] != ''
        ):
            params['policy_action'] = kwargs['fetch_policy_actions']
        if (
            kwargs['exclude_alert_type'] is not None
            and kwargs['exclude_alert_type'] != ''
        ):
            params['exclude_alert_types'] = kwargs['exclude_alert_type'].replace(
                ' ', ''
            )
        return params


    def get_message(client: Client, policy_id: str) -> Any:
        """
        This function is called for getting message for each policy_id
        :param client: Client object
        :param policy_id: Policy id of policy

        :return message_response: Response of message of given policy_id
        """

        headers = {'Authorization': client.api_token, 'Accept': CONTENT_TYPE_JSON}

        try:
            policy_response = client.http_request(
                method='GET',
                url_suffix=URL_SUFFIX['GET_EVENTS'] + f'/{policy_id}',
                headers=headers,
            )
            url = policy_response['alert_event']['collector_message_id']
            message_response = client.http_request(
                method='GET',
                url_suffix=URL_SUFFIX['GET_MESSAGES'] + f'/{url}',
                headers=headers,
            )
            # attack_class_types Key is added to separate out the attack_class' keys in Dashboard
            message_response['message']['attack_class_types'] = []
            for attack_class in list(
                message_response['message']['attack_class'].keys()
            ):
                message_response['message']['attack_class_types'].append(
                    {'Types': attack_class}
                )
            return message_response['message']
        except Exception as ex:
            demisto.debug(str(ex))


    def fetch_incidents(
        client: Client,
        last_run: Dict[str, Any],
        args: Dict[str, Any],
        call_from_test=False,
    ) -> Tuple[dict, list]:
        """
        This function is called for fetching incidents.
        This function gets all policies, then after using ThreadPoolExecutor, for each policy in all policies, get each
        policy and get message from message id obtained from each policy
        This function will execute each interval (default is 1 minute).

        :param client: Client object
        :param last_run: The greatest incident created_time we fetched from last fetch
        :param args: The command arguments provided by user.
        :param call_from_test: Whether calling from test module

        :return next_run: This will be last_run in the next fetch-incidents
        :return incidents: Incidents that will be created in Cortex XSOAR
        """

        # Get the last fetch time and id, if exists
        last_fetch = last_run.get('last_fetch')
        id = last_run.get('id', '')

        first_fetch = args.get('first_fetch')
        # Set first fetch time as default if user leave empty
        first_fetch = DEFAULT_FIRST_FETCH if not first_fetch else first_fetch

        fetch_limit = args.get('max_fetch', DEFAULT_FETCH_LIMIT)

        fetch_policy_actions = args.get('fetch_policy_actions', '')

        exclude_alert_type = args.get('exclude_alert_type', '')

        policy_filter = args.get('policy_filter', '')

        # Handle first time fetch
        if last_fetch is None:
            latest_created_time_date = dateparser.parse(first_fetch)
        else:
            latest_created_time_date = dateparser.parse(last_fetch)
        assert (
            latest_created_time_date is not None
        ), f'could not parse date {first_fetch}'
        latest_created_time_date_str = latest_created_time_date.strftime(
            DATE_FORMAT
        )

        params = fetch_incidents_params(
            start_date=latest_created_time_date_str,
            fetch_limit=fetch_limit,
            fetch_policy_actions=fetch_policy_actions,
            exclude_alert_type=exclude_alert_type,
            policy_filter=policy_filter,
            id=id,
        )

        resp = get_list_policies_api_endpoint(client, params)

        total_records = resp['alert_events']
        if not total_records:
            return last_run, []

        policy_ids = []
        policy_data = {}
        for alert_event in total_records:
            policy_data[alert_event['id']] = alert_event
            policy_ids.append(alert_event['id'])

        items = []
        incidents = []
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_url = {
                executor.submit(get_message, client, policy_id): policy_id
                for policy_id in policy_ids
            }
            for future in as_completed(future_to_url):
                try:
                    items.append([future.result(), future_to_url[future]])
                except Exception as ex:
                    demisto.debug(str(ex))
        for item in items:
            if item[0] is None:
                continue
            result = {'message': item[0], 'policy': policy_data[item[1]]}
            incident = {'name': str(item[1]), 'rawJSON': json.dumps(result)}
            incidents.append(incident)

        # Update last run and add incident if the incident is newer than last fetch
        latest_created_time_date = dateparser.parse(
            total_records[-1]['created_at']
        )
        assert (
            latest_created_time_date is not None
        ), f"failed parsing created_at date: {total_records[-1]['created_at']}"
        latest_created_time_date_str = latest_created_time_date.strftime(
            DATE_FORMAT
        )
        next_run = {
            'last_fetch': latest_created_time_date_str,
            'id': total_records[-1]['id'],
        }
        if call_from_test:
            # Returning None
            return {}, []
        return next_run, incidents


    """ MAIN FUNCTION """


    def main() -> None:
        """
        PARSE AND VALIDATE INTEGRATION PARAMS
        """

        command = demisto.command()
        demisto.info(f'[Agari] Command being called is {command}')

        try:
            url = demisto.params().get('url')
            client_id = demisto.params().get('apikey')
            client_secret = demisto.params().get('apisecret')

            verify_certificate = not demisto.params().get('insecure', False)
            proxy = demisto.params().get('proxy', False)

            # prepare payload
            payload = 'client_id=' + client_id + '&client_secret=' + client_secret

            # prepare client class object
            client = Client(
                base_url=url,
                verify=verify_certificate,
                proxy=proxy,
                request_timeout=DEFAULT_SESSION_TIMEOUT,
                payload=payload,
            )

            # Trim the arguments
            args = strip_blank(demisto.args())

            # This is the call made when pressing the integration Test button.
            if demisto.command() == 'test-module':

                is_fetch = demisto.params().get('isFetch')

                first_fetch_time = demisto.params().get('first_fetch')

                # Set first fetch time as default if user leave empty
                first_fetch_time = (
                    DEFAULT_FIRST_FETCH
                    if not first_fetch_time
                    else first_fetch_time
                )

                incident_type = demisto.params().get('incidentType')

                fetch_limit = demisto.params().get('max_fetch')

                fetch_policy_actions = demisto.params().get('fetch_policy_actions')

                policy_filter = demisto.params().get('policy_filter')

                exclude_alert_type = demisto.params().get('exclude_alert_type')

                result = test_function(
                    client=client,
                    first_fetch_time=first_fetch_time,
                    fetch_limit=fetch_limit,
                    is_fetch=is_fetch,
                    incident_type=incident_type,
                    fetch_policy_actions=fetch_policy_actions,
                    policy_filter=policy_filter,
                    exclude_alert_type=exclude_alert_type,
                )
                demisto.results(result)
            elif demisto.command() == 'apd-list-policy-events':
                return_results(list_policy_events_command(client, args))
            elif demisto.command() == 'apd-list-message-data':
                return_results(list_message_data_command(client, args))
            elif demisto.command() == 'fetch-incidents':
                next_run, incidents = fetch_incidents(
                    client, demisto.getLastRun(), demisto.params()
                )

                demisto.setLastRun(next_run)
                demisto.incidents(incidents)
            elif demisto.command() == 'apd-remediate-message':
                return_results(remediate_message_command(client, args))

        # Log exceptions
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(
                f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}'
            )


    """ ENTRY POINT """

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Agari Phishing Defense', 'end', __line__())
  subtype: python3
  type: python
system: true
